{% extends "base.html" %}

{% block title %}Roulette - Case Clicker{% endblock %}

{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/roulette.css') }}">

<div class="roulette-container">
    <h1>Roulette</h1>
    
    <!-- Previous rolls -->
    <div class="previous-rolls">
        <h3>Previous Rolls</h3>
        <div class="rolls-container">
            <!-- Previous rolls will be added here dynamically -->
        </div>
    </div>

    <!-- Roulette wheel animation -->
    <div class="wheel-container hidden">
        <div class="wheel">
            <!-- Numbers will be added here dynamically -->
        </div>
        <div class="wheel-selector"></div>
    </div>

    <!-- Betting board -->
    <div class="betting-board">
        <!-- Zero -->
        <div class="number zero" data-number="0">0</div>

        <!-- Numbers 1-36 -->
        <div class="numbers-grid">
            {% for row in range(3) %}
                {% for col in range(12) %}
                    {% set number = col * 3 + (3 - row) %}
                    <div class="number {% if number in [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36] %}red{% else %}black{% endif %}"
                         data-number="{{ number }}">
                        {{ number }}
                    </div>
                {% endfor %}
            {% endfor %}
        </div>

        <!-- Special bets -->
        <div class="special-bets">
            <div class="bet-row">
                <div class="special-bet" data-bet="1st12">1st 12</div>
                <div class="special-bet" data-bet="2nd12">2nd 12</div>
                <div class="special-bet" data-bet="3rd12">3rd 12</div>
            </div>
            <div class="bet-row">
                <div class="special-bet" data-bet="1-18">1-18</div>
                <div class="special-bet" data-bet="even">EVEN</div>
                <div class="special-bet red" data-bet="red">RED</div>
                <div class="special-bet black" data-bet="black">BLACK</div>
                <div class="special-bet" data-bet="odd">ODD</div>
                <div class="special-bet" data-bet="19-36">19-36</div>
            </div>
        </div>

        <!-- Add this inside the betting-board div, right after the special-bets div -->
        <div class="betting-overlay">
            <div class="betting-overlay-text">BETTING CLOSED</div>
        </div>
    </div>

    <!-- Betting controls -->
    <div class="betting-controls">
        <div class="quick-bet-buttons">
            <button class="quick-bet increment-bet" data-amount="1">+$1</button>
            <button class="quick-bet increment-bet" data-amount="10">+$10</button>
            <button class="quick-bet increment-bet" data-amount="100">+$100</button>
            <button class="quick-bet increment-bet" data-amount="1000">+$1000</button>
            <button class="quick-bet double-bet">x2</button>
            <button class="quick-bet half-balance">1/2</button>
            <button class="quick-bet max-balance">Max</button>
            <button class="quick-bet repeat-bet" disabled>Repeat</button>
            <button class="quick-bet clear-input">Clear Input</button>
            <button class="quick-bet clear-bets">Clear Bets</button>
        </div>

        <div class="bet-input">
            <div class="bet-controls">
                <button class="bet-adjust" data-action="decrease">-</button>
                <input type="number" id="bet-amount" min="0.01" step="0.01" value="1.00">
                <button class="bet-adjust" data-action="increase">+</button>
            </div>
        </div>

        <div class="current-bets">
            <h3>Current Bets</h3>
            <div class="bets-list">
                <!-- Active bets will be listed here -->
            </div>
            <div class="total-bet">
                Total Bet: $<span class="total-amount">0.00</span>
            </div>
        </div>
    </div>

    <!-- Result notification -->
    <div class="result-notification">
        <div class="result-number-circle">0</div>
        <div class="result-details">
            <div class="result-text">You Won!</div>
            <div class="result-amount">+$0.00</div>
        </div>
    </div>

    <!-- Add this right after the timer-container div -->
    <div class="timer-container">
        <div class="timer-bar"></div>
        <div class="timer-text">
            Betting closes in <span class="countdown">25</span>s
        </div>
    </div>

    <!-- Add these styles for the lightning popup -->
    <div class="lightning-popup">
        <div class="lightning-popup-content">
            <h2>Lightning Numbers</h2>
            <div class="lightning-numbers-grid">
                <!-- Lightning numbers will be added here dynamically -->
            </div>
        </div>
    </div>

    <!-- Add these styles for the lightning win notification -->
    <div class="lightning-win-notification">
        Lightning Win Notification
    </div>
</div>

<div id="confetti-container"></div>

<!-- Add this right after the timer-container div -->
<div class="result-notification">
    <div class="result-number-circle">0</div>
    <div class="result-details">
        <div class="result-text">You Won!</div>
        <div class="result-amount">+$0.00</div>
    </div>
</div>

<!-- Update the JavaScript section -->
{% endblock %}

{% block scripts %}

<script>
document.addEventListener('DOMContentLoaded', () => {
    const betInput = document.getElementById('bet-amount');
    const betsList = document.querySelector('.bets-list');
    const totalAmount = document.querySelector('.total-amount');
    const wheelContainer = document.querySelector('.wheel-container');
    const wheel = document.querySelector('.wheel');
    const rollsContainer = document.querySelector('.rolls-container');
    
    let currentBets = {};
    let previousRolls = [];
    const maxPreviousRolls = 10;
    
    // Constants for number colors
    const RED_NUMBERS = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];
    const BLACK_NUMBERS = [2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35];
    
    // Add these constants at the top with other constants
    const WHEEL_ITEM_WIDTH = 80; // Width of each wheel item
    const WHEEL_ITEM_MARGIN = 5; // Margin on each side
    const WHEEL_ITEM_TOTAL_WIDTH = WHEEL_ITEM_WIDTH + (WHEEL_ITEM_MARGIN * 2); // Total width including margins
    const WHEEL_CENTER_OFFSET = WHEEL_ITEM_TOTAL_WIDTH / 2; // Offset to center the selected number
    
    // Quick bet buttons
    document.querySelectorAll('.quick-bet').forEach(btn => {
        btn.addEventListener('click', () => {
            const currentBalance = parseFloat(document.getElementById('balance').textContent);
            const currentBet = parseFloat(betInput.value) || 0;
            let newAmount;
            
            if (btn.classList.contains('increment-bet')) {
                const incrementAmount = parseFloat(btn.dataset.amount);
                newAmount = currentBet + incrementAmount;
            } else if (btn.classList.contains('half-balance')) {
                newAmount = currentBet / 2;
            } else if (btn.classList.contains('double-bet')) {
                newAmount = Math.min(currentBet * 2, currentBalance);
            } else if (btn.classList.contains('max-balance')) {
                newAmount = currentBalance;
            } else if (btn.classList.contains('clear-bets')) {
                clearBets();
                return;
            } else if (btn.classList.contains('clear-input')) {
                betInput.value = '1.00';
                return;
            }
            
            // Ensure bet doesn't go below 0.01 and doesn't exceed balance
            newAmount = Math.max(0.01, Math.min(newAmount, currentBalance));
            betInput.value = newAmount.toFixed(2);
        });
    });
    
    // Bet adjustment buttons
    document.querySelectorAll('.bet-adjust').forEach(btn => {
        btn.addEventListener('click', () => {
            const currentBet = parseFloat(betInput.value) || 0;
            const currentBalance = parseFloat(document.getElementById('balance').textContent);
            
            if (btn.dataset.action === 'increase') {
                betInput.value = Math.min(currentBet + 1, currentBalance).toFixed(2);
            } else {
                betInput.value = Math.max(currentBet - 1, 0.01).toFixed(2);
            }
        });
    });
    
    // Number and special bet selection
    document.querySelectorAll('.number, .special-bet').forEach(element => {
        element.addEventListener('click', () => {
            // Add check for betting closed
            if (!bettingOpen) {
                return; // Exit early if betting is closed
            }

            const betAmount = parseFloat(betInput.value);
            const currentBalance = parseFloat(document.getElementById('balance').textContent);
            
            if (isNaN(betAmount) || betAmount <= 0) {
                alert('Please enter a valid bet amount');
                return;
            }
            
            if (betAmount > currentBalance) {
                alert('Insufficient funds');
                return;
            }
            
            const betType = element.dataset.number || element.dataset.bet;
            placeBet(betType, betAmount);
            updateBetsList();
        });
    });
    
    let lastBetPattern = null;
    
    function placeBet(betType, amount) {
        // Add check for betting closed
        if (!bettingOpen) {
            console.log('Betting is closed');
            return;
        }

        if (currentBets[betType]) {
            currentBets[betType] += amount;
        } else {
            currentBets[betType] = amount;
        }
        
        // Deduct bet amount from displayed balance immediately
        const balanceElement = document.getElementById('balance');
        const currentBalance = parseFloat(balanceElement.textContent);
        balanceElement.textContent = (currentBalance - amount).toFixed(2);
        
        // Store last bet pattern when a new bet is placed
        lastBetPattern = {...currentBets};
        
        // Enable repeat button when we have a pattern
        document.querySelector('.repeat-bet').disabled = false;
        
        // Update visual selection and add chips
        const element = document.querySelector(`[data-number="${betType}"]`) || 
                       document.querySelector(`[data-bet="${betType}"]`);
        if (element) {
            element.classList.add('selected');
            visualizeChips(element, currentBets[betType]);
        }
    }
    
    function updateBetsList() {
        betsList.innerHTML = '';
        let total = 0;
        
        for (const [betType, amount] of Object.entries(currentBets)) {
            const betItem = document.createElement('div');
            betItem.className = 'bet-item';
            betItem.innerHTML = `
                <span>${getBetDisplayName(betType)}</span>
                <span>$${amount.toFixed(2)}</span>
            `;
            betsList.appendChild(betItem);
            total += amount;
        }
        
        totalAmount.textContent = total.toFixed(2);
    }
    
    function getBetDisplayName(betType) {
        if (betType === '0') return 'Green 0';
        if (!isNaN(betType)) return `Number ${betType}`;
        return betType.charAt(0).toUpperCase() + betType.slice(1);
    }
    
    function calculateTotalBets() {
        return Object.values(currentBets).reduce((sum, amount) => sum + amount, 0);
    }
    
    function clearBets() {
        // Calculate total bet amount to refund
        const totalBetAmount = Object.values(currentBets).reduce((sum, amount) => sum + parseFloat(amount), 0);
        
        // Refund bets to displayed balance
        const balanceElement = document.getElementById('balance');
        const currentBalance = parseFloat(balanceElement.textContent);
        balanceElement.textContent = (currentBalance + totalBetAmount).toFixed(2);
        
        // Clear current bets
        currentBets = {};
        updateBetsList();
        
        // Clear visual selections and chips
        document.querySelectorAll('.selected').forEach(element => {
            element.classList.remove('selected');
            element.querySelectorAll('.chip').forEach(chip => chip.remove());
        });
    }
    
    function createWheelItems() {
        // European roulette wheel order
        const wheelOrder = [
            0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10,
            5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26
        ];
        
        window.wheelOrder = wheelOrder;
        wheel.innerHTML = '';
        
        // Add padding at start (duplicate last few numbers)
        const padding = wheelOrder.slice(-5);
        padding.forEach(number => {
            const item = createWheelItem(number);
            wheel.appendChild(item);
        });
        
        // Add main sequence (3 times for smooth animation)
        for (let i = 0; i < 3; i++) {
            wheelOrder.forEach(number => {
                const item = createWheelItem(number);
                wheel.appendChild(item);
            });
        }
        
        // Add padding at end (duplicate first few numbers)
        const endPadding = wheelOrder.slice(0, 5);
        endPadding.forEach(number => {
            const item = createWheelItem(number);
            wheel.appendChild(item);
        });
    }
    
    function createWheelItem(number) {
        const item = document.createElement('div');
        item.className = `wheel-item ${getNumberColor(number)}`;
        item.textContent = number;
        item.style.width = `${WHEEL_ITEM_WIDTH}px`;
        item.style.margin = `0 ${WHEEL_ITEM_MARGIN}px`;
        return item;
    }
    
    function getNumberColor(number) {
        if (number === 0) return 'green';
        if (RED_NUMBERS.includes(number)) return 'red';
        return 'black';
    }
    
    function updatePreviousRolls(number) {
        previousRolls.unshift(number);
        if (previousRolls.length > maxPreviousRolls) {
            previousRolls.pop();
        }
        
        rollsContainer.innerHTML = '';
        previousRolls.forEach(roll => {
            const rollItem = document.createElement('div');
            rollItem.className = `roll-item ${getNumberColor(roll)}`;
            rollItem.textContent = roll;
            rollsContainer.appendChild(rollItem);
        });
    }
    
    function createConfetti() {
        const container = document.getElementById('confetti-container');
        container.innerHTML = '';
        
        const colors = ['#ffd700', '#ff0000', '#00ff00', '#0000ff', '#ff00ff'];
        
        for (let i = 0; i < 100; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + 'vw';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animation = `confettiFall ${1 + Math.random() * 2}s linear forwards`;
            confetti.style.animationDelay = Math.random() * 3 + 's';
            container.appendChild(confetti);
        }
        
        setTimeout(() => {
            container.innerHTML = '';
        }, 5000);
    }
    
    function findNumberIndex(number) {
        return window.wheelOrder.findIndex(n => n === number);
    }
    
    // Initialize wheel
    createWheelItems();
    
    // Add these variables at the top of your script
    let gameTimer;
    let countdownInterval;
    const BETTING_TIME = 30; // Total time of the round
    const WARNING_TIME = 5;  // Time when bets are closed before spin
    const BETTING_CLOSE_TIME = WARNING_TIME; // When to close bets (5s before end)
    let timeRemaining = BETTING_TIME;
    let bettingOpen = true;
    
    // Add this function to handle the automatic game cycle
    function startGameCycle() {
        timeRemaining = BETTING_TIME;
        bettingOpen = true;
        
        // Remove overlay when new round starts
        document.querySelector('.betting-overlay').classList.remove('active');
        
        // Re-enable all betting buttons
        document.querySelectorAll('.quick-bet, .bet-adjust').forEach(el => {
            el.disabled = false;
        });
        
        // Clear any existing lightning effects and notifications
        document.querySelectorAll('.number.lightning').forEach(el => {
            el.classList.remove('lightning');
            el.removeAttribute('data-multiplier');
            const bolt = el.querySelector('.bolt');
            if (bolt) bolt.remove();
        });
        
        const existingPopup = document.querySelector('.lightning-popup');
        if (existingPopup) {
            existingPopup.remove();
        }
        
        const existingNotification = document.querySelector('.lightning-win-notification');
        if (existingNotification) {
            existingNotification.remove();
        }
        
        updateTimerDisplay();

        // Clear any existing intervals
        clearInterval(countdownInterval);
        clearTimeout(gameTimer);

        // Start countdown
        countdownInterval = setInterval(() => {
            timeRemaining--;
            
            if (timeRemaining === WARNING_TIME) {
                // Close betting and show overlay
                bettingOpen = false;
                document.querySelector('.betting-overlay').classList.add('active');
                document.querySelectorAll('.quick-bet, .bet-adjust').forEach(el => {
                    el.disabled = true;
                });
                
                // Close bets and deduct money
                fetch('/close_roulette_bets', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ bets: currentBets })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        document.getElementById('balance').textContent = data.balance.toFixed(2);
                    }
                });
                
                // Generate lightning numbers when betting closes
                generateLightningNumbers();
            }

            updateTimerDisplay();

            if (timeRemaining === 0) {
                clearInterval(countdownInterval);
                playGame();
            }
        }, 1000);
    }

    function updateTimerDisplay() {
        const timerBar = document.querySelector('.timer-bar');
        const timerText = document.querySelector('.timer-text');
        const countdown = document.querySelector('.countdown');
        
        // Update timer bar width
        const percentage = (timeRemaining / BETTING_TIME) * 100;
        timerBar.style.width = `${percentage}%`;
        
        // Update text and styles based on betting state
        if (timeRemaining <= WARNING_TIME) {
            timerBar.classList.add('warning');
            timerText.classList.add('warning');
            countdown.textContent = timeRemaining;
            timerText.firstChild.textContent = 'Betting is CLOSED! Spinning in ';
        } else {
            timerBar.classList.remove('warning');
            timerText.classList.remove('warning');
            countdown.textContent = timeRemaining - WARNING_TIME;  // Show 25 to 0 for betting time
            timerText.firstChild.textContent = 'Betting closes in ';
        }
    }

    // Remove the inner DOMContentLoaded event and modify the playGame function
    function playGame() {
        try {
            setTimeout(() => {
                // Clear previous winner indicator
                document.querySelectorAll('.number.winner').forEach(el => el.classList.remove('winner'));
                
                // Show wheel animation
                wheelContainer.classList.remove('hidden');
                
                // Calculate wheel position and animate
                const itemWidth = WHEEL_ITEM_TOTAL_WIDTH;
                const paddingItems = 5;
                
                // Get the current lightning numbers from the DOM
                const lightningNumbers = new Set(
                    Array.from(document.querySelectorAll('.number.lightning'))
                        .map(el => parseInt(el.dataset.number))
                );
                
                // Send current bets to server
                const betsToSend = Object.keys(currentBets).length > 0 ? currentBets : {};
                
                fetch('/play_roulette', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        bets: betsToSend,
                        lightningNumbers: Array.from(lightningNumbers)
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(data.error);
                        startGameCycle();
                        return;
                    }

                    const numberIndex = findNumberIndex(data.result);
                    const basePosition = (paddingItems + 37 + numberIndex) * itemWidth;
                    const containerCenter = wheelContainer.offsetWidth / 2;
                    const maxOffset = WHEEL_ITEM_WIDTH * 0.45;
                    const randomOffset = (Math.random() * maxOffset * 2) - maxOffset;
                    const centeringOffset = containerCenter - (WHEEL_ITEM_WIDTH / 2) - WHEEL_ITEM_MARGIN - randomOffset;
                    const finalPosition = basePosition - centeringOffset;

                    // Reset wheel position
                    wheel.style.transition = 'none';
                    wheel.style.transform = 'translateX(0)';
                    wheel.offsetHeight; // Force reflow

                    // Start spinning animation
                    wheel.style.transition = 'transform 4s cubic-bezier(0.22, 1, 0.36, 1)';
                    wheel.style.transform = `translateX(-${finalPosition}px)`;

                    setTimeout(() => {
                        // Update previous rolls
                        updatePreviousRolls(data.result);
                        
                        // Mark winning number
                        const winningTile = document.querySelector(`.number[data-number="${data.result}"]`);
                        if (winningTile) {
                            winningTile.classList.add('winner');
                            
                            // Check if winning number was a lightning number
                            if (winningTile.classList.contains('lightning')) {
                                const multiplier = winningTile.getAttribute('data-multiplier');
                                const notification = document.createElement('div');
                                notification.className = 'lightning-win-notification';
                                notification.textContent = `⚡ Lightning Strike! ${data.result} hit with ${multiplier} multiplier! ⚡`;
                                document.body.appendChild(notification);
                                
                                setTimeout(() => notification.classList.add('visible'), 100);
                                
                                // Remove notification after delay
                                setTimeout(() => {
                                    notification.classList.remove('visible');
                                    setTimeout(() => notification.remove(), 300);
                                }, 3000);
                            }
                        }

                        // Only show result if user placed bets
                        if (Object.keys(currentBets).length > 0) {
                            const notification = document.querySelector('.result-notification');
                            const numberCircle = notification.querySelector('.result-number-circle');
                            const resultText = notification.querySelector('.result-text');
                            const resultAmount = notification.querySelector('.result-amount');

                            numberCircle.textContent = data.result;
                            numberCircle.className = `result-number-circle ${getNumberColor(data.result)}`;

                            // Calculate net win/loss
                            const netWin = data.winnings - data.total_bet;
                            
                            if (netWin > 0) {
                                resultText.textContent = 'You Won!';
                                resultAmount.textContent = `+$${netWin.toFixed(2)}`;
                                resultAmount.className = 'result-amount win';
                                createConfetti();
                            } else {
                                resultText.textContent = 'You Lost!';
                                resultAmount.textContent = `-$${Math.abs(netWin).toFixed(2)}`;
                                resultAmount.className = 'result-amount lose';
                            }

                            notification.classList.add('visible');

                            // Hide notification after 4 seconds
                            setTimeout(() => {
                                notification.classList.remove('visible');
                            }, 4000);

                            // Update balance after result
                            fetch('/update_roulette_balance', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                }
                            })
                            .then(response => response.json())
                            .then(updateData => {
                                if (updateData.success) {
                                    document.getElementById('balance').textContent = updateData.balance.toFixed(2);
                                }
                            });
                        }

                        // Clear bets for next round
                        clearBets();

                        // Start next round after a longer delay to ensure smooth transition
                        setTimeout(startGameCycle, 2000);
                    }, 4000);
                })
                .catch(error => {
                    console.error('Error:', error);
                    startGameCycle();
                });
            }, 1000); // Add 1 second delay to allow timer bar transition to complete
        } catch (error) {
            console.error('Error:', error);
            startGameCycle();
        }
    }

    // Add repeat bet functionality
    document.querySelector('.repeat-bet').addEventListener('click', () => {
        if (!lastBetPattern || !bettingOpen) {
            return;
        }
        
        const currentBalance = parseFloat(document.getElementById('balance').textContent);
        const totalLastBet = Object.values(lastBetPattern).reduce((sum, amount) => sum + amount, 0);
        
        if (totalLastBet > currentBalance) {
            alert('Insufficient funds to repeat last bet');
            return;
        }
        
        // Clear current bets before repeating
        clearBets();
        
        // Replay the last bet pattern
        for (const [betType, amount] of Object.entries(lastBetPattern)) {
            placeBet(betType, amount);
        }
        
        updateBetsList();
    });

    // Start the game cycle when the page loads
    startGameCycle();

    function generateLightningNumbers() {
        // Clear previous lightning numbers
        document.querySelectorAll('.number.lightning').forEach(el => {
            el.classList.remove('lightning');
            el.removeAttribute('data-multiplier');
            const bolt = el.querySelector('.bolt');
            if (bolt) bolt.remove();
        });
        
        // Determine number of lightning numbers (1-5)
        const numLightning = Math.floor(Math.random() * 5) + 1;
        
        // Define multipliers and their weights
        const multipliers = [
            { value: 50, weight: 45 },
            { value: 100, weight: 30 },
            { value: 200, weight: 15 },
            { value: 300, weight: 5 },
            { value: 400, weight: 3 },
            { value: 500, weight: 2 }
        ];
        
        // Create popup
        const popup = document.createElement('div');
        popup.className = 'lightning-popup';
        popup.innerHTML = `
            <h2>Lightning Numbers:</h2>
            <div class="lightning-numbers-grid">
            </div>
        `;
        document.body.appendChild(popup);
        
        // Show popup with delay
        setTimeout(() => popup.classList.add('visible'), 100);
        
        // Get random numbers for lightning
        const numbers = new Set();
        while (numbers.size < numLightning) {
            numbers.add(Math.floor(Math.random() * 37));
        }

        // Apply lightning effect to selected numbers
        const numbersGrid = popup.querySelector('.lightning-numbers-grid');
        
        numbers.forEach(number => {
            // Select random multiplier based on weights
            const totalWeight = multipliers.reduce((sum, m) => sum + m.weight, 0);
            let random = Math.random() * totalWeight;
            let selectedMultiplier;
            
            for (const multiplier of multipliers) {
                random -= multiplier.weight;
                if (random <= 0) {
                    selectedMultiplier = multiplier.value;
                    break;
                }
            }
            
            // Add to popup grid
            const numberItem = document.createElement('div');
            numberItem.className = 'lightning-number-item';
            numberItem.innerHTML = `
                <div class="lightning-number-value">${number}</div>
                <div class="lightning-multiplier-value">${selectedMultiplier}x</div>
            `;
            numbersGrid.appendChild(numberItem);

            // Apply lightning effect to number on the board
            const numberEl = document.querySelector(`.number[data-number="${number}"]`);
            if (numberEl) {
                numberEl.classList.add('lightning');
                numberEl.setAttribute('data-multiplier', `${selectedMultiplier}x`);
                const bolt = document.createElement('div');
                bolt.className = 'bolt';
                numberEl.appendChild(bolt);
            }
        });

        // Remove popup after delay
        setTimeout(() => {
            popup.classList.remove('visible');
            setTimeout(() => popup.remove(), 300);
        }, 3000);

        return numbers;
    }

    // Add this function after the other function definitions
    function visualizeChips(element, amount) {
        // Remove existing chips
        element.querySelectorAll('.chip').forEach(chip => chip.remove());
        
        // Available chip denominations
        const denominations = [1000, 500, 100, 50, 10, 5, 1];
        let remainingAmount = Math.floor(amount); // Ensure we're working with whole numbers
        let chipsToAdd = [];
        
        // Calculate which chips to use
        for (const denom of denominations) {
            while (remainingAmount >= denom) {
                chipsToAdd.push(denom);
                remainingAmount -= denom;
            }
        }
        
        // Add chips to the element (limit to 5 chips max)
        chipsToAdd.slice(0, 5).forEach((denom, index) => {
            const chip = document.createElement('div');
            chip.className = `chip chip-${denom}`;
            
            // Center the chip in the betting area
            chip.style.left = '50%';
            chip.style.top = '50%';
            
            // Add debug info
            console.log(`Adding chip: ${denom} to element:`, element);
            
            element.appendChild(chip);
        });
        
        // Debug info
        console.log(`Visualizing chips for amount: ${amount}`);
        console.log(`Chips to add:`, chipsToAdd);
    }

    // Debug: Verify chip images are loading
    const denominations = [1, 5, 10, 50, 100, 500, 1000];
    denominations.forEach(denom => {
        const img = new Image();
        img.onload = () => console.log(`Chip ${denom} image loaded successfully`);
        img.onerror = () => console.error(`Failed to load chip ${denom} image`);
        img.src = `/static/media/casino/chip_${denom}.png`;
    });
});
</script>
{% endblock %} 