{% extends "base.html" %}

{% block title %}Inventory - Case Clicker{% endblock %}

{% block content %}
<h1>Your Inventory</h1>

<!-- Inventory categories -->
<div class="inventory-categories">
    <button class="category-btn active" data-category="skins">Skins</button>
    <button class="category-btn" data-category="cases">Cases</button>
</div>

<!-- Skins section -->
<div class="inventory-section" id="skins-section">
    <h2>Skins</h2>
    <div id="inventory-items" class="items-grid">
        {% set skin_count = namespace(value=0) %}
        {% for item in inventory %}
        {% if not item.is_case %}
        <div class="skin rarity-{{ item.rarity }}" data-index="{{ skin_count.value }}">
            <div class="skin-image">
                {% if not item.weapon.startswith('★') %}
                    {% set weapon_name = item.weapon.lower()
                        .replace('-', '')
                        .replace(' ', '')
                        .replace('galil ar', 'galil')
                        .replace('galilar', 'galil') %}
                    {% set skin_name = item.name.lower().replace(' ', '_') %}
                    {% set case_mapping = {
                        'csgo': 'weapon_case_1',
                        'esports': 'esports_2013',
                        'bravo': 'operation_bravo_case',
                        'csgo2': 'weapon_case_2', 
                        'esports_winter': 'esports_2013_winter',
                        'winter_offensive': 'winter_offensive_case'
                    } %}
                    {% set case_path = case_mapping[item.case_type] if item.case_type in case_mapping else 'weapon_case_1' %}
                    <img src="{{ url_for('static', filename='media/skins/' + case_path + '/' + weapon_name + '_' + skin_name + '.png') }}" 
                         alt="{{ item.weapon }} | {{ item.name }}">
                {% endif %}
            </div>
            <div class="item-name {{ 'stattrak' if item.stattrak else '' }}">
                {{ 'StatTrak™ ' if item.stattrak }}{{ item.weapon }}
            </div>
            <div class="item-skin">
                {{ item.name }} ({{ item.wear }})
            </div>
            <div class="item-price">${{ "{:.2f}".format(item.price) }}</div>
            <button class="btn sell-btn" data-sell-index="{{ skin_count.value }}">Sell</button>
        </div>
        {% set skin_count.value = skin_count.value + 1 %}
        {% endif %}
        {% endfor %}
    </div>
</div>

<!-- Cases section -->
<div class="inventory-section hidden" id="cases-section">
    <h2>Cases</h2>
    <div class="items-grid">
        {% for item in inventory %}
            {% if item.is_case %}
            <div class="case-item">
                <img src="{{ url_for('static', filename='media/cases/' + item.image) }}" alt="{{ item.name }}">
                <div class="item-details">
                    <h3>{{ item.name }}</h3>
                    <p>Quantity: {{ item.quantity }}</p>
                    <button class="btn-small" onclick="openCase('{{ item.type }}')">Open Case</button>
                </div>
            </div>
            {% endif %}
        {% endfor %}
    </div>
</div>

<!-- Add the case opening overlay -->
<div id="case-opening-overlay" class="hidden">
    <audio id="spinning-sound" preload="auto">
        <source src="{{ url_for('static', filename='media/case_spinning.mp3') }}" type="audio/mpeg">
    </audio>
    <div class="spinner-container">
        <div class="spinner">
            <!-- Items will be inserted here dynamically -->
        </div>
        <div class="spinner-selector"></div>
    </div>
</div>

<!-- Add the showcase overlay -->
<div id="showcase-overlay" class="showcase-overlay" style="display: none;">
    <audio id="showcase-sound" preload="auto">
        <source src="{{ url_for('static', filename='media/case_showcase.mp3') }}" type="audio/mpeg">
    </audio>
    <div class="showcase-container">
        <div class="showcase-item">
            <div class="showcase-name"></div>
            <div class="showcase-details"></div>
            <div class="showcase-price"></div>
        </div>
        <div class="showcase-buttons">
            <button class="showcase-continue">Continue</button>
            <button class="showcase-sell">Sell</button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Make RANKS available to JavaScript
const RANKS = {
    0: "Silver I",
    1: "Silver II", 
    2: "Silver III",
    3: "Silver IV",
    4: "Silver Elite",
    5: "Silver Elite Master",
    6: "Gold Nova I",
    7: "Gold Nova II",
    8: "Gold Nova III",
    9: "Gold Nova Master",
    10: "Master Guardian I",
    11: "Master Guardian II",
    12: "Master Guardian Elite",
    13: "Distinguished Master Guardian",
    14: "Legendary Eagle",
    15: "Legendary Eagle Master",
    16: "Supreme Master First Class",
    17: "The Global Elite"
};

// Set initial view based on server parameter
document.addEventListener('DOMContentLoaded', async () => {
    const initialView = '{{ initial_view }}';
    if (initialView) {
        const button = document.querySelector(`[data-category="${initialView}"]`);
        if (button) {
            button.click();
        }
    }
    
    // If we're starting on the skins view, refresh it
    if (initialView === 'skins' || !initialView) {
        await refreshSkinsSection();
    }
});

// Add category switching functionality
document.querySelectorAll('.category-btn').forEach(button => {
    button.addEventListener('click', async () => {
        // Remove active class from all buttons
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Add active class to clicked button
        button.classList.add('active');
        
        // Hide all sections
        document.querySelectorAll('.inventory-section').forEach(section => {
            section.classList.add('hidden');
        });
        
        // Show selected section
        const category = button.dataset.category;
        const section = document.getElementById(`${category}-section`);
        section.classList.remove('hidden');
        
        // If switching to skins section, refresh it
        if (category === 'skins') {
            await refreshSkinsSection();
        }
    });
});

// Update the sell button click handler
document.querySelectorAll('.sell-btn').forEach(button => {
    button.addEventListener('click', async function() {
        // Prevent double-clicking
        if (this.disabled) return;
        this.disabled = true;

        const itemElement = this.closest('.skin');
        if (!itemElement) {
            console.error('Could not find parent skin element');
            this.disabled = false;
            return;
        }
        
        // Get the index from the sell button's data attribute
        const index = parseInt(this.dataset.sellIndex);
        if (isNaN(index)) {
            console.error('Invalid sell index:', this.dataset.sellIndex);
            this.disabled = false;
            return;
        }

        try {
            const response = await fetch(`/sell/${index}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.error) {
                alert(data.error);
                this.disabled = false;
                return;
            }
            
            // Update balance
            document.getElementById('balance').textContent = data.balance.toFixed(2);
            
            // Remove the sold item from display with animation
            itemElement.style.animation = 'fadeOut 0.3s';
            setTimeout(() => {
                itemElement.remove();
                
                // Update remaining items' indices
                document.querySelectorAll('.skin').forEach((skin, newIndex) => {
                    skin.dataset.index = newIndex;
                    // Update the sell button's data-sell-index
                    const sellBtn = skin.querySelector('.sell-btn');
                    if (sellBtn) {
                        sellBtn.dataset.sellIndex = newIndex;
                    }
                });
            }, 300);
            
        } catch (error) {
            console.error('Error:', error);
            alert('Failed to sell item');
        } finally {
            this.disabled = false;
        }
    });
});

// Replace the hardcoded caseContents object with dynamic loading
const caseContents = {};

// Function to load case contents
async function loadCaseContents(caseType) {
    if (!caseContents[caseType]) {
        try {
            const response = await fetch(`/data/case_contents/${caseType}`);
            const data = await response.json();
            
            // Transform the data into the required format and include valid wears
            caseContents[caseType] = {
                name: data.name,
                contents: {
                    GOLD: data.skins.gold.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "GOLD",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    })),
                    RED: data.skins.red.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "RED",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    })),
                    PINK: data.skins.pink.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "PINK",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    })),
                    PURPLE: data.skins.purple.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "PURPLE",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    })),
                    BLUE: data.skins.blue.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "BLUE",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    }))
                }
            };
        } catch (error) {
            console.error(`Error loading case contents for ${caseType}:`, error);
            return null;
        }
    }
    return caseContents[caseType];
}

// Update the openCase function
async function openCase(caseType) {
    try {
        // Load case contents if not already loaded
        await loadCaseContents(caseType);
        
        // Store initial rank before opening case
        const initialRank = parseInt(document.querySelector('.current-rank').dataset.rank || '0');
        
        // Send request to open case
        const response = await fetch(`/open/${caseType}`);
        const data = await response.json();
        
        console.log('Case opening response:', data);
        
        if (data.error) {
            alert(data.error);
            return;
        }
        
        // Update balance
        document.getElementById('balance').textContent = data.balance.toFixed(2);
        
        // Update rank progress if exp data is available
        if (data.exp !== undefined && data.rank !== undefined) {
            // Check for level up using initial rank
            if (data.rank > initialRank) {
                console.log('Level up detected in openCase!', {
                    initialRank,
                    newRank: data.rank,
                    rankName: data.rankName
                });
                // Store level up data to show after showcase
                data.item.levelUp = {
                    fromRank: initialRank,
                    toRank: data.rank
                };
            }
            updateRankProgress(data.exp, data.rank, data.rankName, data.nextRankExp);
        }
        
        // Update case quantity in UI
        const caseElement = document.querySelector(`.case-item button[onclick*="${caseType}"]`)
            ?.closest('.case-item');
        if (!caseElement) {
            console.error('Case element not found');
            return;
        }
        
        const quantityElement = caseElement.querySelector('p');
        const currentQuantity = parseInt(quantityElement.textContent.match(/\d+/)[0]);
        
        const newQuantity = currentQuantity - 1;
        quantityElement.textContent = `Quantity: ${newQuantity}`;
        
        // If quantity is 0, remove the case item
        if (newQuantity <= 0) {
            caseElement.remove();
        }
        
        // Show case opening animation
        const overlay = document.getElementById('case-opening-overlay');
        const spinner = document.querySelector('.spinner');
        const spinningSound = document.getElementById('spinning-sound');
        
        spinner.innerHTML = '';
        overlay.classList.remove('hidden');

        // Play the spinning sound
        spinningSound.currentTime = 0;
        spinningSound.play();

        // Generate random items with the actual item
        const { items, winningPosition } = generateRandomItems(data.item);
        
        // Create spinner items
        const elements = items.map((item, index) => {
            const element = createItemElement(item);
            if (index === winningPosition) {
                element.dataset.winning = 'true';
            }
            return element;
        });

        elements.forEach(element => spinner.appendChild(element));

        // Initial position
        spinner.style.transition = 'none';
        spinner.style.transform = 'translateX(0)';
        spinner.offsetHeight; // Force reflow
        
        const itemWidth = 200;
        const spinnerContainer = document.querySelector('.spinner-container');
        const containerWidth = spinnerContainer.offsetWidth;
        const centerOffset = (containerWidth / 2) - (itemWidth / 2);
        const randomOffset = Math.floor(Math.random() * itemWidth) - (itemWidth / 2);
        const finalPosition = (winningPosition * itemWidth) - centerOffset + randomOffset;
        
        // Spin animation
        spinner.style.transition = 'transform 6s cubic-bezier(0.12, 0.39, 0.01, 1)';
        spinner.style.transform = `translateX(-${finalPosition}px)`;
        
        // Hide overlay and show result
        setTimeout(() => {
            overlay.classList.add('hidden');
            spinningSound.pause();
            console.log('Showing showcase with item:', data.item);
            showItemShowcase(data.item);
            
            // Clear any stored items to prevent duplicates
            sessionStorage.removeItem('newItem');
        }, 6300);
        
    } catch (error) {
        console.error('Error:', error);
        alert('Failed to open case');
    }
}

function generateRandomItems(actualItem) {
    const itemPools = {
        BLUE: caseContents[actualItem.case_type].contents.BLUE,
        PURPLE: caseContents[actualItem.case_type].contents.PURPLE,
        PINK: caseContents[actualItem.case_type].contents.PINK,
        RED: caseContents[actualItem.case_type].contents.RED,
        GOLD: caseContents[actualItem.case_type].contents.GOLD
    };

    function randomFromPool(rarity) {
        const pool = itemPools[rarity];
        const randomItem = {...pool[Math.floor(Math.random() * pool.length)]};
        const hasStattrak = Math.random() < 0.1;
        
        // Use the valid wears from the item data
        const validWears = randomItem.validWears && randomItem.validWears.length > 0 
            ? randomItem.validWears 
            : ['FN', 'MW', 'FT', 'WW', 'BS'];
        const wear = validWears[Math.floor(Math.random() * validWears.length)];
        
        return {
            ...randomItem,
            stattrak: hasStattrak,
            wear: wear,
            case_type: actualItem.case_type
        };
    }

    function generateRandomItem() {
        // Roll for rarity
        const roll = Math.random() * 100;
        let chosenRarity;
        
        if (roll < 0.26) {  // 0.26% chance for Gold
            chosenRarity = "GOLD";
        } else if (roll < 0.26 + 0.90) {  // 0.90% chance for Red
            chosenRarity = "RED";
        } else if (roll < 0.26 + 0.90 + 4.10) {  // 4.10% chance for Pink
            chosenRarity = "PINK";
        } else if (roll < 0.26 + 0.90 + 4.10 + 20.08) {  // 20.08% chance for Purple
            chosenRarity = "PURPLE";
        } else {  // Remaining ~74.66% chance for Blue
            chosenRarity = "BLUE";
        }

        return randomFromPool(chosenRarity);
    }

    const items = [];
    const totalItems = 100;
    const winningPosition = 85;
    
    // Generate random items for the wheel
    for (let i = 0; i < totalItems; i++) {
        if (i === winningPosition) {
            // Place the actual item from the server exactly at the winning position
            items.push({
                weapon: actualItem.weapon,
                name: actualItem.name,
                rarity: actualItem.rarity,
                wear: actualItem.wear,
                stattrak: actualItem.stattrak,
                price: actualItem.price,
                case_type: actualItem.case_type
            });
        } else {
            // Generate a random item based on rarity percentages
            items.push(generateRandomItem());
        }
    }
    
    return { items, winningPosition };
}

function createItemElement(item) {
    const div = document.createElement('div');
    div.className = `spinner-item rarity-${item.rarity}`;
    div.classList.add(item.wear);
    
    div.dataset.item = JSON.stringify(item);
    
    // Create image container
    const imageContainer = document.createElement('div');
    imageContainer.className = 'spinner-item-image';
    
    if (item.rarity === 'GOLD') {
        // For gold items, always show "Rare Special Item"
        div.innerHTML = `
            <div class="spinner-item-image">
                <img src="/static/media/cases/rare_item.png" alt="Rare Special Item">
            </div>
            <div class="item-name">★</div>
            <div class="item-skin">Rare Special Item</div>
        `;
    } else {
        // For regular skins, add the image
        const weaponName = item.weapon.toLowerCase()
            .replace('-', '')
            .replace(' ', '')
            .replace('553', '553')
            .replace('galil ar', 'galil')
            .replace('galilar', 'galil');
        const skinName = item.name.toLowerCase()
            .replace(/ /g, '_');
        
        // Update case path mapping
        const casePathMapping = {
            'csgo': 'weapon_case_1',
            'esports': 'esports_2013',
            'bravo': 'operation_bravo_case',
            'csgo2': 'weapon_case_2',
            'esports_winter': 'esports_2013_winter',
            'winter_offensive': 'winter_offensive_case'
        };
        const casePath = casePathMapping[item.case_type] || 'weapon_case_1';
        
        const img = document.createElement('img');
        img.src = `/static/media/skins/${casePath}/${weaponName}_${skinName}.png`;
        img.alt = `${item.weapon} | ${item.name}`;
        
        imageContainer.appendChild(img);
        div.appendChild(imageContainer);
        
        div.innerHTML += `
            <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
                ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
            </div>
            <div class="item-skin">
                ${item.name}
            </div>
        `;
    }
    return div;
}

function showItemShowcase(item) {
    // Add the rank data to the item if it wasn't included
    if (item && !item.exp && !item.rank) {
        item = {
            ...item,
            exp: parseFloat(document.querySelector('.exp-info').textContent),
            rank: parseInt(document.querySelector('.current-rank').dataset.rank),
            rankName: document.querySelector('.current-rank').textContent,
            nextRankExp: document.querySelector('.exp-info').textContent.includes('/') ? 
                parseInt(document.querySelector('.exp-info').textContent.split('/')[1]) : null
        };
    }

    const showcase = document.getElementById('showcase-overlay');
    const showcaseSound = document.getElementById('showcase-sound');
    const showcaseContainer = showcase.querySelector('.showcase-container');
    
    // Clear any existing buttons container
    const existingButtons = showcaseContainer.querySelector('.showcase-buttons');
    if (existingButtons) {
        existingButtons.remove();
    }
    
    // Create and set up all elements first
    const nameElement = document.createElement('div');
    nameElement.className = `showcase-name ${item.stattrak ? 'stattrak' : ''}`;
    
    const detailsElement = document.createElement('div');
    detailsElement.className = 'showcase-details';
    
    const priceElement = document.createElement('div');
    priceElement.className = 'showcase-price';
    
    // Create image element
    const imageElement = document.createElement('img');
    
    // For knives/gold items, use the actual knife image instead of rare_item.png
    if (item.rarity === 'GOLD') {
        // Get case path mapping
        const casePathMapping = {
            'csgo': 'weapon_case_1',
            'esports': 'esports_2013',
            'bravo': 'operation_bravo_case',
            'csgo2': 'weapon_case_2',
            'esports_winter': 'esports_2013_winter',
            'winter_offensive': 'winter_offensive_case'
        };
        const casePath = casePathMapping[item.case_type] || 'weapon_case_1';
        
        // Get the weapon and skin name from the item
        const weaponName = item.weapon.toLowerCase()
            .replace('-', '')
            .replace(' ', '')
            .replace('★', '')
            .replace('553', '553')
            .replace('galil ar', 'galil')
            .replace('galilar', 'galil');
            
        const skinName = item.name.toLowerCase().replace(/ /g, '_');
        
        // Set the image source to the actual knife image
        imageElement.src = `/static/media/skins/${casePath}/${weaponName}_${skinName}.png`;
    } else {
        // For non-knife skins, use the same image logic as before
        const weaponName = item.weapon.toLowerCase()
            .replace('-', '')
            .replace(' ', '')
            .replace('553', '553')
            .replace('galil ar', 'galil')
            .replace('galilar', 'galil');
        const skinName = item.name.toLowerCase().replace(/ /g, '_');
        
        const casePathMapping = {
            'csgo': 'weapon_case_1',
            'esports': 'esports_2013',
            'bravo': 'operation_bravo_case',
            'csgo2': 'weapon_case_2',
            'esports_winter': 'esports_2013_winter',
            'winter_offensive': 'winter_offensive_case'
        };
        const casePath = casePathMapping[item.case_type] || 'weapon_case_1';
        
        imageElement.src = `/static/media/skins/${casePath}/${weaponName}_${skinName}.png`;
    }
    
    imageElement.alt = `${item.weapon} | ${item.name}`;
    
    // Fetch the price from case data
    fetch(`/data/case_contents/${item.case_type}`)
        .then(response => response.json())
        .then(caseData => {
            // Find the item's price in the case data
            let price = 0;
            for (const [grade, skins] of Object.entries(caseData.skins)) {
                for (const skin of skins) {
                    if (skin.weapon === item.weapon && skin.name === item.name) {
                        const prices = skin.prices;
                        const wearKey = 'NO' in prices ? 'NO' : item.wear;
                        price = item.stattrak ? 
                            (prices[`ST_${wearKey}`] || 0) : 
                            (prices[wearKey] || 0);
                        break;
                    }
                }
                if (price > 0) break;
            }
            
            // Update the item's price
            item.price = price;
            priceElement.textContent = `$${price.toFixed(2)}`;
            
            // Update the price in the inventory display if it exists
            const inventoryItem = document.querySelector(`[data-index="${document.querySelectorAll('.skin').length}"]`);
            if (inventoryItem) {
                const priceDisplay = inventoryItem.querySelector('.item-price');
                if (priceDisplay) {
                    priceDisplay.textContent = `$${price.toFixed(2)}`;
                }
            }
        })
        .catch(error => {
            console.error('Error fetching case data:', error);
            priceElement.textContent = '$0.00';
        });

    // Update showcase content
    const itemContainer = showcase.querySelector('.showcase-item');
    itemContainer.innerHTML = ''; // Clear existing content
    
    // Add all elements to the container
    itemContainer.appendChild(imageElement);
    itemContainer.appendChild(nameElement);
    itemContainer.appendChild(detailsElement);
    itemContainer.appendChild(priceElement);
    
    // Remove any existing rarity classes from container
    showcaseContainer.className = 'showcase-container';
    showcaseContainer.classList.add(`rarity-${item.rarity}`);
    
    // Set text content
    nameElement.textContent = `${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon} | ${item.name}`;
    detailsElement.textContent = `${item.wear} • ${item.rarity === 'GOLD' ? 'Rare Special Item' : item.rarity}`;
    
    // Create buttons container and buttons
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'showcase-buttons';
    
    const continueButton = document.createElement('button');
    continueButton.className = 'showcase-continue';
    continueButton.textContent = 'Continue';
    
    const sellButton = document.createElement('button');
    sellButton.className = 'showcase-sell';
    sellButton.textContent = 'Sell';
    
    buttonsContainer.appendChild(continueButton);
    buttonsContainer.appendChild(sellButton);
    showcaseContainer.appendChild(buttonsContainer);
    
    // Add button handlers
    continueButton.onclick = async () => {
        showcase.style.display = 'none';
        showcaseSound.pause();
        await refreshSkinsSection();
        
        // Show level up celebration if we stored level up data
        if (item.levelUp) {
            console.log('Showing level up celebration:', item.levelUp);
            createConfetti();
            showLevelUpBanner(RANKS[item.levelUp.toRank]);
        }
        if (item.exp !== undefined && item.rank !== undefined) {
            updateRankProgress(item.exp, item.rank, item.rankName, item.nextRankExp);
        }
    };
    
    sellButton.onclick = async () => {
        try {
            const response = await fetch('/sell/last', { method: 'POST' });
            const data = await response.json();
            
            if (data.error) {
                alert(data.error);
                return;
            }
            
            // Update balance
            document.getElementById('balance').textContent = data.balance.toFixed(2);
            
            // Show level up celebration if we stored level up data
            if (item.levelUp) {
                console.log('Showing level up celebration:', item.levelUp);
                createConfetti();
                showLevelUpBanner(RANKS[item.levelUp.toRank]);
            }
            if (item.exp !== undefined && item.rank !== undefined) {
                updateRankProgress(item.exp, item.rank, item.rankName, item.nextRankExp);
            }
            
            // Close showcase
            showcase.style.display = 'none';
            showcaseSound.pause();
            
        } catch (error) {
            console.error('Error:', error);
            alert('Failed to sell item');
        }
    };
    
    // Show overlay and play sound
    showcase.style.display = 'flex';
    showcaseSound.currentTime = 0;
    showcaseSound.play();
}

// Add this new function to update the rank progress UI
function updateRankProgress(exp, rank, rankName, nextRankExp) {
    console.log('Updating rank progress:', { exp, rank, rankName, nextRankExp });
    // Update rank name and store the rank value
    const rankElement = document.querySelector('.current-rank');
    if (rankElement) {
        rankElement.textContent = rankName;
        rankElement.dataset.rank = rank;  // Store the rank value
    }
    
    // Update progress bar
    const progressFill = document.querySelector('.progress-fill');
    if (progressFill) {
        if (nextRankExp) {
            const percentage = (exp / nextRankExp * 100).toFixed(2);
            progressFill.style.width = `${percentage}%`;
        } else {
            progressFill.style.width = '100%';
        }
    }
    
    // Update exp text
    const expInfo = document.querySelector('.exp-info');
    if (expInfo) {
        if (nextRankExp) {
            expInfo.textContent = `${Math.floor(exp)}/${nextRankExp} EXP`;
        } else {
            expInfo.textContent = 'MAX RANK';
        }
    }
}

// Update the refreshSkinsSection function
async function refreshSkinsSection() {
    try {
        // Disable all sell buttons while refreshing to prevent double-selling
        document.querySelectorAll('.sell-btn').forEach(btn => btn.disabled = true);
        
        const response = await fetch('/get_inventory');
        const data = await response.json();
        
        if (data.error) {
            console.error('Error:', data.error);
            return;
        }
        
        const inventoryItems = document.getElementById('inventory-items');
        if (!inventoryItems) {
            console.error('Could not find inventory-items element');
            return;
        }
        
        // Clear current inventory immediately
        inventoryItems.innerHTML = '';
        
        // Get only non-case items and maintain their original order
        const skinItems = data.inventory.filter(item => !item.is_case);
        
        // Create and append all items at once
        const fragment = document.createDocumentFragment();
        
        skinItems.forEach((item, skinIndex) => {
            const skinDiv = document.createElement('div');
            skinDiv.className = `skin rarity-${item.rarity}`;
            skinDiv.dataset.index = skinIndex;
            
            const weaponName = item.weapon.toLowerCase()
                .replace('-', '')
                .replace(' ', '')
                .replace('553', '553')
                .replace('galil ar', 'galil')
                .replace('galilar', 'galil');
            const skinName = item.name.toLowerCase().replace(/ /g, '_');
            
            const caseMapping = {
                'csgo': 'weapon_case_1',
                'esports': 'esports_2013',
                'bravo': 'operation_bravo_case',
                'csgo2': 'weapon_case_2',
                'esports_winter': 'esports_2013_winter',
                'winter_offensive': 'winter_offensive_case'
            };
            const casePath = caseMapping[item.case_type] || 'weapon_case_1';
            
            skinDiv.innerHTML = `
                <div class="skin-image">
                    ${!item.weapon.startsWith('★') ? `
                        <img src="/static/media/skins/${casePath}/${weaponName}_${skinName}.png" 
                             alt="${item.weapon} | ${item.name}">
                    ` : ''}
                </div>
                <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
                    ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
                </div>
                <div class="item-skin">
                    ${item.name} (${item.wear})
                </div>
                <div class="item-price">$${item.price.toFixed(2)}</div>
                <button class="btn sell-btn" data-sell-index="${skinIndex}">Sell</button>
            `;
            
            fragment.appendChild(skinDiv);
        });
        
        // Add all items to the DOM at once
        inventoryItems.appendChild(fragment);
        
        // Add click handlers to all sell buttons
        document.querySelectorAll('.sell-btn').forEach(button => {
            button.addEventListener('click', async function() {
                if (this.disabled) return;
                this.disabled = true;
                
                const itemElement = this.closest('.skin');
                if (!itemElement) {
                    console.error('Could not find parent skin element');
                    this.disabled = false;
                    return;
                }
                
                const index = parseInt(this.dataset.sellIndex);
                if (isNaN(index)) {
                    console.error('Invalid sell index:', this.dataset.sellIndex);
                    this.disabled = false;
                    return;
                }
                
                try {
                    const response = await fetch(`/sell/${index}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        alert(data.error);
                        return;
                    }
                    
                    // Update balance
                    document.getElementById('balance').textContent = data.balance.toFixed(2);
                    
                    // Remove the sold item with animation
                    itemElement.style.animation = 'fadeOut 0.3s';
                    setTimeout(() => {
                        itemElement.remove();
                        
                        // Update remaining items' indices
                        document.querySelectorAll('.skin').forEach((skin, newIndex) => {
                            skin.dataset.index = newIndex;
                            const sellBtn = skin.querySelector('.sell-btn');
                            if (sellBtn) {
                                sellBtn.dataset.sellIndex = newIndex;
                            }
                        });
                    }, 300);
                    
                } catch (error) {
                    console.error('Error:', error);
                    alert('Failed to sell item');
                } finally {
                    this.disabled = false;
                }
            });
        });
        
    } catch (error) {
        console.error('Error refreshing skins section:', error);
    } finally {
        // Re-enable all sell buttons
        document.querySelectorAll('.sell-btn').forEach(btn => btn.disabled = false);
    }
}

// Update the DOMContentLoaded event handler
document.addEventListener('DOMContentLoaded', () => {
    // Check if there's a new item to add
    const newItemJson = sessionStorage.getItem('newItem');
    if (newItemJson) {
        const item = JSON.parse(newItemJson);
        const inventoryItems = document.getElementById('inventory-items');
        const newIndex = inventoryItems.children.length;
        
        const skinDiv = document.createElement('div');
        skinDiv.className = `skin rarity-${item.rarity}`;
        skinDiv.dataset.index = newIndex;
        
        // Create weapon image
        const weaponName = item.weapon.toLowerCase()
            .replace('-', '')
            .replace(' ', '')
            .replace('553', '553');
        const skinName = item.name.toLowerCase().replace(' ', '_');
        
        skinDiv.innerHTML = `
            <div class="skin-image">
                ${!item.weapon.startsWith('★') ? `
                    <img src="/static/media/skins/weapon_case_1/${weaponName}_${skinName}.png" 
                         alt="${item.weapon} | ${item.name}">
                ` : ''}
            </div>
            <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
                ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
            </div>
            <div class="item-skin">
                ${item.name} (${item.wear})
            </div>
            <div class="item-price">$${item.price.toFixed(2)}</div>
            <button class="btn sell-btn" data-sell-index="${newIndex}">Sell</button>
        `;
        
        // Add sell button handler
        const sellBtn = skinDiv.querySelector('.sell-btn');
        if (sellBtn) {
            sellBtn.addEventListener('click', async function() {
                const itemElement = this.closest('.skin');
                if (!itemElement) return;
                const index = parseInt(itemElement.dataset.index);
                try {
                    const response = await fetch(`/sell/${index}`, {
                        method: 'POST'
                    });
                    const data = await response.json();
                    
                    if (data.error) {
                        alert(data.error);
                        return;
                    }
                    
                    // Update balance
                    document.getElementById('balance').textContent = data.balance.toFixed(2);
                    
                    // Remove the sold item
                    itemElement.style.animation = 'fadeOut 0.3s';
                    setTimeout(() => {
                        itemElement.remove();
                        
                        // Update remaining indices
                        document.querySelectorAll('.skin').forEach((skin, newIndex) => {
                            skin.dataset.index = newIndex;
                        });
                    }, 300);
                    
                } catch (error) {
                    console.error('Error:', error);
                    alert('Failed to sell item');
                }
            });
        }
        
        inventoryItems.appendChild(skinDiv);
        
        // Clear the stored item
        sessionStorage.removeItem('newItem');
    }
    
    // Add click handlers to all existing sell buttons
    document.querySelectorAll('.sell-btn').forEach(button => {
        button.addEventListener('click', async function() {
            const itemElement = this.closest('.skin');
            if (!itemElement) {
                console.error('Could not find parent skin element');
                return;
            }
            
            const index = parseInt(itemElement.dataset.index);
            if (isNaN(index)) {
                console.error('Invalid index:', itemElement.dataset.index);
                return;
            }
            
            try {
                const response = await fetch(`/sell/${index}`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.error) {
                    alert(data.error);
                    return;
                }
                
                // Update balance
                document.getElementById('balance').textContent = data.balance.toFixed(2);
                
                // Remove the sold item from display with animation
                itemElement.style.animation = 'fadeOut 0.3s';
                setTimeout(() => {
                    itemElement.remove();
                    
                    // Update remaining items' indices
                    document.querySelectorAll('.skin').forEach((skin, newIndex) => {
                        skin.dataset.index = newIndex;
                    });
                }, 300);
                
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to sell item');
            }
        });
    });
});

// Update the updateInventoryDisplay function
async function updateInventoryDisplay() {
    try {
        const response = await fetch('/get_inventory');
        const data = await response.json();
        
        if (data.error) {
            console.error('Error:', data.error);
            return;
        }
        
        const inventoryItems = document.getElementById('inventory-items');
        if (!inventoryItems) {
            console.error('Could not find inventory-items element');
            return;
        }
        
        // Clear current inventory
        inventoryItems.innerHTML = '';
        
        // Update case path mapping
        const casePathMapping = {
            'csgo': 'weapon_case_1',
            'esports': 'esports_2013',
            'bravo': 'operation_bravo_case',
            'csgo2': 'weapon_case_2',
            'esports_winter': 'esports_2013_winter',
            'winter_offensive': 'winter_offensive_case'
        };
        
        // Add each item
        let skinIndex = 0;
        for (const item of data.inventory) {
            if (!item.is_case) {
                // Create the skin element
                const skinDiv = document.createElement('div');
                skinDiv.className = `skin rarity-${item.rarity}`;
                skinDiv.dataset.index = skinIndex;  // Set the correct index
                
                const weaponName = item.weapon.toLowerCase()
                    .replace('-', '')
                    .replace(' ', '')
                    .replace('553', '553')
                    .replace('galil ar', 'galil')
                    .replace('galilar', 'galil');
                const skinName = item.name.toLowerCase().replace(/ /g, '_');
                const casePath = casePathMapping[item.case_type] || 'weapon_case_1';
                
                skinDiv.innerHTML = `
                    <div class="skin-image">
                        ${!item.weapon.startsWith('★') ? `
                            <img src="/static/media/skins/${casePath}/${weaponName}_${skinName}.png" 
                                 alt="${item.weapon} | ${item.name}">
                        ` : ''}
                    </div>
                    <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
                        ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
                    </div>
                    <div class="item-skin">
                        ${item.name} (${item.wear})
                    </div>
                    <div class="item-price">$${item.price.toFixed(2)}</div>
                    <button class="btn sell-btn" data-sell-index="${skinIndex}">Sell</button>
                `;
                
                // Add sell button handler
                const sellBtn = skinDiv.querySelector('.sell-btn');
                if (sellBtn) {
                    sellBtn.addEventListener('click', async function() {
                        await sellItem(skinIndex);
                    });
                }
                
                inventoryItems.appendChild(skinDiv);
                skinIndex++;
            }
        }
        
    } catch (error) {
        console.error('Error updating inventory:', error);
    }
}

// Add this function after the existing scripts
function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    document.body.appendChild(confettiContainer);
    
    const colors = ['#ffd700', '#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff'];
    
    // Create 100 confetti pieces
    for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animation = `confettiFall ${1 + Math.random() * 2}s linear forwards`;
        confetti.style.animationDelay = Math.random() * 3 + 's';
        confettiContainer.appendChild(confetti);
    }
    
    // Remove the container after animations complete
    setTimeout(() => {
        confettiContainer.remove();
    }, 5000);
}

function showLevelUpBanner(newRank) {
    const banner = document.createElement('div');
    banner.className = 'level-up-banner';
    banner.innerHTML = `<h2>LEVEL UP: ${newRank}</h2>`;
    document.body.appendChild(banner);
    
    // Remove the banner after animation
    setTimeout(() => {
        banner.remove();
    }, 3000);
}
</script>
{% endblock %} 