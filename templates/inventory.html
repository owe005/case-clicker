{% extends "base.html" %}

{% block title %}Inventory - Case Clicker{% endblock %}

{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/inventory.css') }}">

<h1>Your Inventory</h1>

<!-- Inventory categories -->
<div class="inventory-categories">
    <button class="category-btn active" data-category="skins">Skins</button>
    <button class="category-btn" data-category="cases">Cases</button>
    <!-- Move sort buttons into skins-section -->
</div>

<!-- Skins section -->
<div class="inventory-section" id="skins-section">
    <div class="inventory-controls">
        <div class="sort-controls">
            <button class="sort-btn" data-sort="rarity">Sort by Rarity</button>
            <button class="sort-btn" data-sort="price">Sort by Price</button>
        </div>
        <button id="sell-all-btn" class="sell-all-btn">Sell All: $0.00</button>
    </div>
    <div id="inventory-items" class="items-grid">
        {% set stacks = {} %}
        {% for item in inventory %}
            {% if not item.is_case %}
                {% set stack_key = item.weapon + '|' + item.name + '|' + item.wear + '|' + item.stattrak|string %}
                {% if stack_key not in stacks %}
                    {% set _ = stacks.update({stack_key: {'items': [], 'count': 0}}) %}
                {% endif %}
                {% set _ = stacks[stack_key]['items'].append(item) %}
                {% set _ = stacks[stack_key].update({'count': stacks[stack_key]['count'] + 1}) %}
            {% endif %}
        {% endfor %}

        {% for stack_key, stack in stacks.items() %}
            {% set first_item = stack['items'][0] %}
            {% if stack['count'] > 1 %}
                <!-- Stacked items -->
                <div class="skin rarity-{{ first_item.rarity }} skin-stack" data-stack-key="{{ stack_key }}">
                    <div class="skin-image">
                        {% if not first_item.weapon.startswith('★') %}
                            {% set weapon_name = first_item.weapon.lower()
                                .replace('-', '')
                                .replace(' ', '')
                                .replace('553', '553')
                                .replace('galil ar', 'galil')
                                .replace('galilar', 'galil') %}
                            {% set skin_name = first_item.name.lower().replace(' ', '_') %}
                            {% set case_path = CASE_MAPPING[first_item.case_type] if first_item.case_type in CASE_MAPPING else 'weapon_case_1' %}
                            <div class="skin-image-wrapper">
                                <img src="{{ url_for('static', filename='media/skins/' + case_path + '/' + weapon_name + '_' + skin_name + '.png') }}" 
                                     alt="{{ first_item.weapon }} | {{ first_item.name }}">
                                <span class="skin-count">x{{ stack['count'] }}</span>
                            </div>
                        {% endif %}
                    </div>
                    <div class="item-name {{ 'stattrak' if first_item.stattrak else '' }}">
                        {{ 'StatTrak™ ' if first_item.stattrak }}{{ first_item.weapon }}
                    </div>
                    <div class="item-skin">
                        {{ first_item.name }} ({{ first_item.wear }})
                    </div>
                    <div class="stack-expand">Click to expand</div>
                    <div class="stacked-items hidden">
                        {% for item in stack['items'] %}
                            <div class="skin-item" data-index="{{ loop.index0 }}" data-float-value="{{ item.float_value }}">
                                <div class="item-float">Float: {{ "%.8f"|format(item.float_value|float) }}</div>
                                <div class="item-price">${{ "{:.2f}".format(item.price) }}</div>
                                <button class="btn sell-btn" data-sell-index="{{ loop.index0 }}">Sell</button>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            {% else %}
                <!-- Single items -->
                <div class="skin rarity-{{ first_item.rarity }}" data-index="0" data-float-value="{{ first_item.float_value }}">
                    <div class="skin-image">
                        {% if not first_item.weapon.startswith('★') %}
                            {% set weapon_name = first_item.weapon.lower()
                                .replace('-', '')
                                .replace(' ', '')
                                .replace('553', '553')
                                .replace('galil ar', 'galil')
                                .replace('galilar', 'galil') %}
                            {% set skin_name = first_item.name.lower().replace(' ', '_') %}
                            {% set case_path = CASE_MAPPING[first_item.case_type] if first_item.case_type in CASE_MAPPING else 'weapon_case_1' %}
                            <div class="skin-image-wrapper">
                                <img src="{{ url_for('static', filename='media/skins/' + case_path + '/' + weapon_name + '_' + skin_name + '.png') }}" 
                                     alt="{{ first_item.weapon }} | {{ first_item.name }}">
                            </div>
                        {% endif %}
                    </div>
                    <div class="item-name {{ 'stattrak' if first_item.stattrak else '' }}">
                        {{ 'StatTrak™ ' if first_item.stattrak }}{{ first_item.weapon }}
                    </div>
                    <div class="item-skin">
                        {{ first_item.name }} ({{ first_item.wear }})
                    </div>
                    <div class="item-float">Float: {{ "%.8f"|format(first_item.float_value|float) }}</div>
                    <div class="item-price">${{ "{:.2f}".format(first_item.price) }}</div>
                    <button class="btn sell-btn" data-sell-index="0">Sell</button>
                </div>
            {% endif %}
        {% endfor %}
    </div>
</div>

<!-- Cases section -->
<div class="inventory-section hidden" id="cases-section">
    <div class="items-grid">
        {% set has_cases = namespace(value=false) %}
        {% for item in inventory %}
            {% if item.is_case %}
                {% set has_cases.value = true %}
                <div class="case-item">
                    <img src="{{ url_for('static', filename='media/cases/' + item.image) }}" alt="{{ item.name }}">
                    <div class="item-details">
                        <h3>{{ item.name }}</h3>
                        <p>Quantity: {{ item.quantity }}</p>
                        <div class="case-buttons">
                            <button class="btn-small" onclick="openCase('{{ item.type }}', 1)">Open 1x</button>
                            {% if upgrades.multi_open >= 2 and item.quantity >= 2 %}
                            <button class="btn-small" onclick="openCase('{{ item.type }}', 2)" style="display: {{ 'block' if upgrades.multi_open >= 2 else 'none' }}">Open 2x</button>
                            {% endif %}
                            {% if upgrades.multi_open >= 3 and item.quantity >= 3 %}
                            <button class="btn-small" onclick="openCase('{{ item.type }}', 3)" style="display: {{ 'block' if upgrades.multi_open >= 3 else 'none' }}">Open 3x</button>
                            {% endif %}
                            {% if upgrades.multi_open >= 4 and item.quantity >= 4 %}
                            <button class="btn-small" onclick="openCase('{{ item.type }}', 4)" style="display: {{ 'block' if upgrades.multi_open >= 4 else 'none' }}">Open 4x</button>
                            {% endif %}
                            {% if upgrades.multi_open >= 5 and item.quantity >= 5 %}
                            <button class="btn-small" onclick="openCase('{{ item.type }}', 5)" style="display: {{ 'block' if upgrades.multi_open >= 5 else 'none' }}">Open 5x</button>
                            {% endif %}
                        </div>
                    </div>
                </div>
            {% endif %}
        {% endfor %}
        
        {% if not has_cases.value %}
        <div class="no-cases-message">
            <h2>No Cases Found</h2>
            <p>You don't have any cases in your inventory.</p>
            <a href="{{ url_for('shop') }}" class="btn-buy-cases">Buy Cases</a>
        </div>
        {% endif %}
    </div>
</div>

<!-- Update the case opening overlay -->
<div id="case-opening-overlay" class="hidden">
    <audio id="spinning-sound" preload="auto">
        <source src="{{ url_for('static', filename='media/case_spinning.mp3') }}" type="audio/mpeg">
    </audio>
    <div class="spinner-containers">
        <div class="spinner-container">
            <div class="spinner"></div>
            <div class="spinner-selector"></div>
        </div>
        <div class="spinner-container hidden">
            <div class="spinner"></div>
            <div class="spinner-selector"></div>
        </div>
        <div class="spinner-container hidden">
            <div class="spinner"></div>
            <div class="spinner-selector"></div>
        </div>
        <div class="spinner-container hidden">
            <div class="spinner"></div>
            <div class="spinner-selector"></div>
        </div>
        <div class="spinner-container hidden">
            <div class="spinner"></div>
            <div class="spinner-selector"></div>
        </div>
    </div>
</div>

<!-- Update the showcase overlay -->
<div id="showcase-overlay" class="showcase-overlay" style="display: none;">
    <audio id="showcase-sound" preload="auto">
        <source src="{{ url_for('static', filename='media/case_showcase.mp3') }}" type="audio/mpeg">
    </audio>
    <div class="showcase-container">
        <div class="showcase-items">
            <div class="showcase-item">
                <div class="showcase-name"></div>
                <div class="showcase-details"></div>
                <div class="showcase-price"></div>
            </div>
            <div class="showcase-item hidden">
                <div class="showcase-name"></div>
                <div class="showcase-details"></div>
                <div class="showcase-price"></div>
            </div>
            <div class="showcase-item hidden">
                <div class="showcase-name"></div>
                <div class="showcase-details"></div>
                <div class="showcase-price"></div>
            </div>
            <div class="showcase-item hidden">
                <div class="showcase-name"></div>
                <div class="showcase-details"></div>
                <div class="showcase-price"></div>
            </div>
            <div class="showcase-item hidden">
                <div class="showcase-name"></div>
                <div class="showcase-details"></div>
                <div class="showcase-price"></div>
            </div>
        </div>
        <div class="showcase-buttons">
            <button class="showcase-continue">Continue</button>
            <button class="showcase-sell">Sell All</button>
        </div>
    </div>
</div>

<!-- Add this before the closing body tag -->
<div id="sell-all-modal" class="modal hidden">
    <div class="modal-content">
        <h3>Confirm Sell All</h3>
        <p>Are you sure you want to sell all skins for <span id="modal-price">$0.00</span>?</p>
        <div class="modal-buttons">
            <button id="confirm-sell-all" class="btn">Confirm</button>
            <button id="cancel-sell-all" class="btn">Cancel</button>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>

// Set initial view based on server parameter
document.addEventListener('DOMContentLoaded', async () => {
    const initialView = '{{ initial_view }}';
    if (initialView) {
        const button = document.querySelector(`[data-category="${initialView}"]`);
        if (button) {
            button.click();
        }
    }
    
    // Remove the automatic refresh on load
    // if (initialView === 'skins' || !initialView) {
    //     await refreshSkinsSection();
    // }

    // Just update the sell all button instead
    updateSellAllButton();
});

// Add category switching functionality
document.querySelectorAll('.category-btn').forEach(button => {
    button.addEventListener('click', async () => {
        // Remove active class from all buttons
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Add active class to clicked button
        button.classList.add('active');
        
        // Hide all sections
        document.querySelectorAll('.inventory-section').forEach(section => {
            section.classList.add('hidden');
        });
        
        // Show selected section
        const category = button.dataset.category;
        const section = document.getElementById(`${category}-section`);
        section.classList.remove('hidden');
        
        // Only refresh if explicitly switching to skins from another category
        if (category === 'skins' && !section.classList.contains('active')) {
            await refreshSkinsSection();
        }
        section.classList.add('active');
    });
});

// Update the sellButtonHandler
const sellButtonHandler = async function() {
    if (this.disabled) return;
    this.disabled = true;

    // Get either the single skin or the skin-item parent
    const skin = this.closest('.skin');
    if (!skin) {
        console.error('Could not find parent skin element');
        this.disabled = false;
        return;
    }
    
    // Get the item data
    const itemData = {
        weapon: skin.querySelector('.item-name').textContent.replace('StatTrak™ ', '').trim(),
        name: skin.querySelector('.item-skin').textContent.split('(')[0].trim(),
        wear: skin.querySelector('.item-skin').textContent.match(/\((.*?)\)/)[1],
        stattrak: skin.querySelector('.item-name').classList.contains('stattrak'),
        float_value: parseFloat(skin.dataset.floatValue)
    };
    
    try {
        const response = await fetch(`/sell/item`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                item: itemData,
                quantity: 1
            })
        });
        
        const data = await response.json();
        
        if (data.error) {
            alert(data.error);
            return;
        }
        
        // Handle achievement/rank updates
        handleAchievementComplete(data);
        
        // Update balance display
        const balanceElement = document.querySelector('.balance');
        if (balanceElement) {
            balanceElement.textContent = `Balance: $${data.balance.toFixed(2)}`;
        }
        
        // Remove the sold item with animation
        skin.style.animation = 'fadeOut 0.3s';
        setTimeout(() => {
            skin.remove();
            updateRemainingIndices();
            updateSellAllButton();
        }, 300);
        
    } catch (error) {
        console.error('Error:', error);
        alert('Failed to sell item');
    }
    
    this.disabled = false;
};

// Update the initial sell button event listeners to use the handler
document.querySelectorAll('.sell-btn').forEach(button => {
    button.addEventListener('click', sellButtonHandler);
});

// Add this helper function
function updateRemainingIndices() {
    // Update indices for all visible items in the main grid
    const inventoryGrid = document.getElementById('inventory-items');
    const visibleItems = Array.from(inventoryGrid.children).filter(item => 
        item.style.display !== 'none' && !item.classList.contains('hidden')
    );
    
    visibleItems.forEach((item, index) => {
        item.dataset.index = index;
        const sellBtn = item.querySelector('.sell-btn');
        if (sellBtn) {
            sellBtn.dataset.sellIndex = index;
        }
    });
}

// Add this function to show a quantity selection modal
function showQuantityModal(maxQuantity) {
    return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
            <div class="modal-content">
                <h3>Select Quantity</h3>
                <input type="range" min="1" max="${maxQuantity}" value="1" id="quantity-slider">
                <div id="quantity-display">1</div>
                <div class="modal-buttons">
                    <button id="confirm-quantity" class="btn">Confirm</button>
                    <button id="cancel-quantity" class="btn">Cancel</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        const slider = modal.querySelector('#quantity-slider');
        const display = modal.querySelector('#quantity-display');
        
        slider.addEventListener('input', () => {
            display.textContent = slider.value;
        });
        
        modal.querySelector('#confirm-quantity').addEventListener('click', () => {
            const quantity = parseInt(slider.value);
            modal.remove();
            resolve(quantity);
        });
        
        modal.querySelector('#cancel-quantity').addEventListener('click', () => {
            modal.remove();
            resolve(null);
        });
    });
}

// Replace the hardcoded caseContents object with dynamic loading
const caseContents = {};

// Function to load case contents
async function loadCaseContents(caseType) {
    if (!caseContents[caseType]) {
        try {
            const response = await fetch(`/data/case_contents/${caseType}`);
            const data = await response.json();
            
            // Transform the data into the required format and include valid wears
            caseContents[caseType] = {
                name: data.name,
                contents: {
                    CONTRABAND: (data.skins.contraband || []).map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "CONTRABAND",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    })),
                    GOLD: data.skins.gold.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "GOLD",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    })),
                    RED: data.skins.red.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "RED",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    })),
                    PINK: data.skins.pink.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "PINK",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    })),
                    PURPLE: data.skins.purple.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "PURPLE",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    })),
                    BLUE: data.skins.blue.map(item => ({
                        weapon: item.weapon,
                        name: item.name,
                        rarity: "BLUE",
                        validWears: Object.keys(item.prices || {}).filter(k => !k.startsWith('ST_'))
                    }))
                }
            };
        } catch (error) {
            console.error(`Error loading case contents for ${caseType}:`, error);
            return null;
        }
    }
    return caseContents[caseType];
}

// Keep the complete openCase function with all the case opening logic
async function openCase(caseType, count = 1) {
    console.log('=== Starting openCase ===');
    console.log('Parameters:', { caseType, count });
    
    // Create a promise to track animation completion
    let animationComplete = false;
    let overlayRemoved = false;
    
    try {
        // Check for existing overlay
        const existingOverlay = document.getElementById('case-opening-overlay');
        console.log('Initial overlay check:', { exists: !!existingOverlay });
        
        if (existingOverlay) {
            console.log('Removing existing overlay');
            existingOverlay.remove();
        }
        
        console.log('Creating new overlay');
        let overlay = document.createElement('div');
        overlay.id = 'case-opening-overlay';
        overlay.className = 'hidden';
        overlay.innerHTML = `
            <audio id="spinning-sound" preload="auto">
                <source src="/static/media/case_spinning.mp3" type="audio/mpeg">
            </audio>
            <div class="spinner-containers">
                ${Array(5).fill(0).map((_, i) => `
                    <div class="spinner-container ${i > 0 ? 'hidden' : ''}">
                        <div class="spinner"></div>
                        <div class="spinner-selector"></div>
                    </div>
                `).join('')}
            </div>
        `;
        
        console.log('Appending overlay to document.body');
        document.body.appendChild(overlay);
        
        // Create a mutation observer to track if overlay is removed
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                for (const node of mutation.removedNodes) {
                    if (node.id === 'case-opening-overlay' && !animationComplete) {
                        overlayRemoved = true;
                        observer.disconnect();
                        // Recreate overlay if it was removed before animation completed
                        if (!animationComplete) {
                            document.body.appendChild(overlay.cloneNode(true));
                        }
                    }
                }
            }
        });
        
        // Start observing
        observer.observe(document.body, { childList: true, subtree: true });
        
        console.log('Waiting for DOM update');
        await new Promise(resolve => setTimeout(resolve, 50));
        
        if (count < 1 || count > 5) {
            console.error('Invalid case count:', count);
            return;
        }

        try {
            console.log('Loading case contents');
            await loadCaseContents(caseType);
            
            console.log('Fetching case open response');
            const response = await fetch(`/open/${caseType}?count=${count}`);
            const data = await response.json();
            console.log('Server response:', data);
            
            if (data.error) {
                console.error('Server returned error:', data.error);
                alert(data.error);
                return;
            }

            // Get fresh reference to overlay and elements
            console.log('Getting fresh overlay reference');
            overlay = document.getElementById('case-opening-overlay');
            console.log('Fresh overlay check:', { exists: !!overlay });
            
            if (!overlay) {
                console.error('Overlay missing after server response');
                console.log('Current DOM state:', {
                    body: document.body.innerHTML,
                    overlayElements: document.querySelectorAll('#case-opening-overlay'),
                    activeElement: document.activeElement
                });
                throw new Error('Overlay element not found after server response');
            }
            
            const spinningSound = document.getElementById('spinning-sound');
            const spinnerContainers = overlay.querySelectorAll('.spinner-container');
            console.log('Elements check:', {
                hasSound: !!spinningSound,
                containerCount: spinnerContainers.length
            });
            
            // Generate random items for each spinner
            const spinnerResults = [];
            for (let i = 0; i < count; i++) {
                const { items, winningPosition } = generateRandomItems(data.items[i]);
                spinnerResults.push({ items, winningPosition });
            }
            
            // Show overlay and play sound
            overlay.classList.remove('hidden');
            if (spinningSound) {
                spinningSound.currentTime = 0;
                spinningSound.play().catch(e => console.warn('Audio playback failed:', e));
            }
            
            // Clear and show/hide spinner containers based on count
            spinnerContainers.forEach((container, index) => {
                if (index < count) {
                    // Show and clear containers we'll use
                    container.classList.remove('hidden');
                    const spinner = container.querySelector('.spinner');
                    if (spinner) {
                        spinner.innerHTML = '';
                        
                        // Create spinner items only for active containers
                        const result = spinnerResults[index];
                        const elements = result.items.map((item, itemIndex) => {
                            const element = createItemElement(item);
                            if (itemIndex === result.winningPosition) {
                                element.dataset.winning = 'true';
                            }
                            return element;
                        });

                        elements.forEach(element => spinner.appendChild(element));
                        
                        // Set initial position
                        spinner.style.transition = 'none';
                        spinner.style.transform = 'translateX(0)';
                    }
                } else {
                    // Completely hide unused containers
                    container.classList.add('hidden');
                    const spinner = container.querySelector('.spinner');
                    if (spinner) {
                        spinner.innerHTML = '';
                    }
                }
            });
            
            // Force reflow for active spinners
            spinnerContainers.forEach((container, index) => {
                if (index < count) {
                    const spinner = container.querySelector('.spinner');
                    if (spinner) {
                        spinner.offsetHeight; // Force reflow
                    }
                }
            });
            
            // Start synchronized spin animation only for active spinners
            spinnerContainers.forEach((container, index) => {
                if (index < count) {
                    const spinner = container.querySelector('.spinner');
                    if (spinner) {
                        const result = spinnerResults[index];
                        
                        const itemWidth = 200;
                        const containerWidth = container.offsetWidth;
                        const centerOffset = (containerWidth / 2) - (itemWidth / 2);
                        const randomOffset = Math.floor(Math.random() * itemWidth) - (itemWidth / 2);
                        const finalPosition = (result.winningPosition * itemWidth) - centerOffset + randomOffset;
                        
                        // Use the same transition for all spinners
                        spinner.style.transition = 'transform 6s cubic-bezier(0.12, 0.39, 0.01, 1)';
                        // Start all animations in the next frame
                        requestAnimationFrame(() => {
                            spinner.style.transform = `translateX(-${finalPosition}px)`;
                        });
                    }
                }
            });
            
            // Update UI elements
            document.getElementById('balance').textContent = data.balance.toFixed(2);
            
            if (data.exp !== undefined && data.rank !== undefined) {
                updateRankProgress(data.exp, data.rank, data.rankName, data.nextRankExp);
            }
            
            // Handle achievement if present
            if (data.achievement) {
                window.pendingAchievement = data.achievement;
            }
            
            // Update case buttons visibility
            updateCaseButtonsVisibility(data.upgrades);
            
            // Update case quantity
            updateCaseQuantity(caseType, count);
            
            // Update the animation completion handler
            setTimeout(() => {
                animationComplete = true;
                observer.disconnect();
                
                const currentOverlay = document.getElementById('case-opening-overlay');
                if (currentOverlay) {
                    currentOverlay.classList.add('hidden');
                    const sound = document.getElementById('spinning-sound');
                    if (sound) {
                        sound.pause();
                    }
                }
                showItemShowcase(data.items);
                sessionStorage.removeItem('newItem');
            }, 6300);
            
        } catch (error) {
            console.error('Error in openCase:', error);
            alert('Failed to open case');
        } finally {
            // Clean up observer if it's still active
            if (!animationComplete) {
                observer.disconnect();
            }
        }
    } catch (error) {
        console.error('Error in openCase:', error);
        alert('Failed to open case');
    }
}

// Add helper function to update case buttons visibility
function updateCaseButtonsVisibility(upgrades) {
    document.querySelectorAll('.case-item').forEach(caseItem => {
        const quantityElement = caseItem.querySelector('p');
        const quantity = parseInt(quantityElement.textContent.split(': ')[1]);
        const buttons = caseItem.querySelectorAll('.case-buttons button');
        
        buttons.forEach((button, index) => {
            const count = index + 1;
            if (count > 1) {
                button.style.display = (upgrades.multi_open >= count && quantity >= count) ? 'block' : 'none';
            }
        });
    });
}

// Update the updateCaseQuantity function
function updateCaseQuantity(caseType, count) {
    const caseElement = document.querySelector(`.case-item button[onclick*="${caseType}"]`)?.closest('.case-item');
    if (caseElement) {
        const quantityElement = caseElement.querySelector('p');
        const currentQuantity = parseInt(quantityElement.textContent.match(/\d+/)[0]);
        const newQuantity = currentQuantity - count;
        
        quantityElement.textContent = `Quantity: ${newQuantity}`;
        
        if (newQuantity <= 0) {
            caseElement.remove();
            
            // Check if there are any remaining cases
            const remainingCases = document.querySelectorAll('.case-item');
            if (remainingCases.length === 0) {
                // No cases left, show the "No Cases" message
                const itemsGrid = document.querySelector('#cases-section .items-grid');
                const noCasesMessage = `
                    <div class="no-cases-message">
                        <h2>No Cases Found</h2>
                        <p>You don't have any cases in your inventory.</p>
                        <a href="/shop" class="btn-buy-cases">Buy Cases</a>
                    </div>
                `;
                itemsGrid.innerHTML = noCasesMessage;
            }
        } else {
            // Update button visibility after changing quantity
            updateCaseButtonsVisibility({ multi_open: 5 }); // Assuming max multi_open level is 5
        }
    }
}

function generateRandomItems(actualItem) {
    const itemPools = {
        CONTRABAND: caseContents[actualItem.case_type].contents.CONTRABAND || [],  // Add CONTRABAND pool
        GOLD: caseContents[actualItem.case_type].contents.GOLD,
        RED: caseContents[actualItem.case_type].contents.RED,
        PINK: caseContents[actualItem.case_type].contents.PINK,
        PURPLE: caseContents[actualItem.case_type].contents.PURPLE,
        BLUE: caseContents[actualItem.case_type].contents.BLUE
    };

    function randomFromPool(rarity) {
        const pool = itemPools[rarity];
        if (!pool || pool.length === 0) {
            // Fallback to GOLD pool if the requested rarity pool is empty
            return randomFromPool('GOLD');
        }
        const randomItem = {...pool[Math.floor(Math.random() * pool.length)]};
        const hasStattrak = Math.random() < 0.1;
        
        // Use the valid wears from the item data
        const validWears = randomItem.validWears && randomItem.validWears.length > 0 
            ? randomItem.validWears 
            : ['FN', 'MW', 'FT', 'WW', 'BS'];
        const wear = validWears[Math.floor(Math.random() * validWears.length)];
        
        return {
            ...randomItem,
            stattrak: hasStattrak,
            wear: wear,
            case_type: actualItem.case_type
        };
    }

    function generateRandomItem() {
        // Roll for rarity with normal percentages
        const roll = Math.random() * 100;
        let chosenRarity;
        
        // Check if contraband items exist for this case
        const hasContraband = itemPools.CONTRABAND && itemPools.CONTRABAND.length > 0;
        
        if (hasContraband && roll < 0.026) {  // 0.026% chance for Contraband (normal rate)
            chosenRarity = "CONTRABAND";
        } else if (roll < (hasContraband ? 0.286 : 0.26)) {  // 0.26% chance for Gold
            chosenRarity = "GOLD";
        } else if (roll < (hasContraband ? 1.186 : 1.16)) {  // 0.90% chance for Red
            chosenRarity = "RED";
        } else if (roll < (hasContraband ? 5.286 : 5.26)) {  // 4.10% chance for Pink
            chosenRarity = "PINK";
        } else if (roll < (hasContraband ? 25.366 : 25.34)) {  // 20.08% chance for Purple
            chosenRarity = "PURPLE";
        } else {  // Remaining ~74.66% chance for Blue
            chosenRarity = "BLUE";
        }

        return randomFromPool(chosenRarity);
    }

    const items = [];
    const totalItems = 100;
    const winningPosition = 85;
    
    // Generate random items for the wheel
    for (let i = 0; i < totalItems; i++) {
        if (i === winningPosition) {
            // Place the actual item from the server exactly at the winning position
            items.push({
                weapon: actualItem.weapon,
                name: actualItem.name,
                rarity: actualItem.rarity,
                wear: actualItem.wear,
                stattrak: actualItem.stattrak,
                price: actualItem.price,
                case_type: actualItem.case_type
            });
        } else {
            // Generate a random item based on rarity percentages
            items.push(generateRandomItem());
        }
    }
    
    return { items, winningPosition };
}

function createItemElement(item) {
    const div = document.createElement('div');
    div.className = `spinner-item rarity-${item.rarity}`;
    div.classList.add(item.wear);
    
    div.dataset.item = JSON.stringify(item);
    
    // Create image container
    const imageContainer = document.createElement('div');
    imageContainer.className = 'spinner-item-image';
    
    if (item.rarity === 'GOLD') {
        // For gold items, always show "Rare Special Item"
        div.innerHTML = `
            <div class="spinner-item-image">
                <img src="/static/media/cases/rare_item.png" alt="Rare Special Item">
            </div>
            <div class="item-name">★</div>
            <div class="item-skin">Rare Special Item</div>
        `;
    } else if (item.rarity === 'CONTRABAND') {
        const casePath = casePathMapping[item.case_type] || 'weapon_case_1';
        
        const weaponName = item.weapon.toLowerCase()
            .replace('-', '')
            .replace(' ', '')
            .replace('553', '553')
            .replace('galil ar', 'galil')
            .replace('galilar', 'galil');
            
        const skinName = item.name.toLowerCase().replace(/ /g, '_');
        
        const img = document.createElement('img');
        img.src = `/static/media/skins/${casePath}/${weaponName}_${skinName}.png`;
        img.alt = `${item.weapon} | ${item.name}`;
        imageContainer.appendChild(img);
        div.appendChild(imageContainer);
        
        div.innerHTML += `
            <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
                ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
            </div>
            <div class="item-skin">
                ${item.name}
            </div>
        `;
    } else {
        // For regular skins, add the image
        const weaponName = item.weapon.toLowerCase()
            .replace('-', '')
            .replace(' ', '')
            .replace('553', '553')
            .replace('galil ar', 'galil')
            .replace('galilar', 'galil')  // Add this line to handle 'galilar' case
            .replace(/\s+/g, '');  // Remove any remaining spaces
            
        const skinName = item.name.toLowerCase()
            .replace(/ /g, '_');
        
        const casePath = CASE_MAPPING[item.case_type] || 'weapon_case_1';
        
        const img = document.createElement('img');
        img.src = `/static/media/skins/${casePath}/${weaponName}_${skinName}.png`;
        img.alt = `${item.weapon} | ${item.name}`;
        
        imageContainer.appendChild(img);
        div.appendChild(imageContainer);
        
        div.innerHTML += `
            <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
                ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
            </div>
            <div class="item-skin">
                ${item.name}
            </div>
        `;
    }
    return div;
}

function showItemShowcase(items) {
    const showcase = document.getElementById('showcase-overlay');
    const showcaseSound = document.getElementById('showcase-sound');
    const showcaseContainer = showcase.querySelector('.showcase-container');
    const showcaseItems = showcase.querySelectorAll('.showcase-item');
    
    // Clear any existing buttons container
    const existingButtons = showcaseContainer.querySelector('.showcase-buttons');
    if (existingButtons) {
        existingButtons.remove();
    }
    
    // Show/hide showcase items based on number of items
    showcaseItems.forEach((itemContainer, index) => {
        if (index < items.length) {
            // Show and populate container for actual items
            itemContainer.classList.remove('hidden');
            itemContainer.innerHTML = ''; // Clear existing content
            
            // Create image element
            const imageElement = document.createElement('img');
            
            // Always show actual item image in showcase, even for gold items
            const weaponName = items[index].weapon.toLowerCase()
                .replace('-', '')
                .replace(' ', '')
                .replace('553', '553');
            const skinName = items[index].name.toLowerCase().replace(' ', '_');
            
            const casePath = CASE_MAPPING[items[index].case_type] || 'weapon_case_1';
            
            imageElement.src = `/static/media/skins/${casePath}/${weaponName}_${skinName}.png`;
            imageElement.alt = `${items[index].weapon} | ${items[index].name}`;
            itemContainer.appendChild(imageElement);
            
            // Add name, details, and price elements
            const nameElement = document.createElement('div');
            nameElement.className = `showcase-name ${items[index].stattrak ? 'stattrak' : ''}`;
            nameElement.textContent = `${items[index].stattrak ? 'StatTrak™ ' : ''}${items[index].weapon} | ${items[index].name}`;
            
            const detailsElement = document.createElement('div');
            detailsElement.className = 'showcase-details';
            detailsElement.textContent = `${items[index].wear} • ${items[index].rarity === 'GOLD' ? 'Rare Special Item' : items[index].rarity}`;
            
            const priceElement = document.createElement('div');
            priceElement.className = 'showcase-price';
            priceElement.textContent = `$${items[index].price.toFixed(2)}`;
            
            itemContainer.appendChild(nameElement);
            itemContainer.appendChild(detailsElement);
            itemContainer.appendChild(priceElement);
        } else {
            // Hide unused containers completely
            itemContainer.classList.add('hidden');
            itemContainer.innerHTML = '';
        }
    });
    
    // Remove any existing rarity classes from container
    showcaseContainer.className = 'showcase-container';
    showcaseContainer.classList.add(`rarity-${items[0].rarity}`);
    
    // Create buttons container and buttons
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'showcase-buttons';
    
    const continueButton = document.createElement('button');
    continueButton.className = 'showcase-continue';
    continueButton.textContent = 'Continue';
    
    const sellButton = document.createElement('button');
    sellButton.className = 'showcase-sell';
    sellButton.textContent = items.length > 1 ? 'Sell All' : 'Sell';
    
    buttonsContainer.appendChild(continueButton);
    buttonsContainer.appendChild(sellButton);
    showcaseContainer.appendChild(buttonsContainer);
    
    // Add button handlers
    continueButton.onclick = async () => {
        showcase.style.display = 'none';
        showcaseSound.pause();
        await refreshSkinsSection();
        
        // Show achievement popup if one was completed during case opening
        if (window.pendingAchievement) {
            showAchievementPopup(window.pendingAchievement);
            window.pendingAchievement = null;  // Clear the pending achievement
        }
        
        // Show level up celebration if we stored level up data
        if (items[0].levelUp) {
            console.log('Showing level up celebration:', items[0].levelUp);
            createConfetti();
            showLevelUpBanner(RANKS[items[0].levelUp.toRank]);
        }
    };
    
    sellButton.onclick = async () => {
        try {
            sellButton.disabled = true;
            
            const response = await fetch('/sell/last', { 
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    count: items.length  // Send the number of items to sell
                })
            });
            
            const data = await response.json();
            
            if (data.error) {
                console.error('Error selling items:', data.error);
                alert(data.error);
                return;
            }
            
            // Show success message with total amount
            const totalAmount = data.sold_price.toFixed(2);
            const message = items.length > 1 
                ? `Successfully sold ${items.length} items for $${totalAmount}`
                : `Successfully sold item for $${totalAmount}`;
            
            // Optional: Show a toast or notification with the message
            
            // Show level up celebration if needed
            if (items[0].levelUp) {
                console.log('Showing level up celebration:', items[0].levelUp);
                createConfetti();
                showLevelUpBanner(RANKS[items[0].levelUp.toRank]);
            }
            
            // Close showcase
            showcase.style.display = 'none';
            showcaseSound.pause();
            
            // Refresh the inventory display
            await refreshSkinsSection();
            
        } catch (error) {
            console.error('Error:', error);
            alert('Failed to sell items');
        } finally {
            sellButton.disabled = false;
        }
    };
    
    // Show the showcase overlay
    showcase.style.display = 'flex';
    showcaseSound.currentTime = 0;
    showcaseSound.play();
}

// Add this new function to update the rank progress UI
function updateRankProgress(exp, rank, rankName, nextRankExp) {
    console.log('Updating rank progress:', { exp, rank, rankName, nextRankExp });
    // Update rank name and store the rank value
    const rankElement = document.querySelector('.current-rank');
    if (rankElement) {
        rankElement.textContent = rankName;
        rankElement.dataset.rank = rank;  // Store the rank value
    }
    
    // Update progress bar
    const progressFill = document.querySelector('.progress-fill');
    if (progressFill) {
        if (nextRankExp) {
            const percentage = (exp / nextRankExp * 100).toFixed(2);
            progressFill.style.width = `${percentage}%`;
        } else {
            progressFill.style.width = '100%';
        }
    }
    
    // Update exp text
    const expInfo = document.querySelector('.exp-info');
    if (expInfo) {
        if (nextRankExp) {
            expInfo.textContent = `${Math.floor(exp)}/${nextRankExp} EXP`;
        } else {
            expInfo.textContent = 'MAX RANK';
        }
    }
}

// Update the refreshSkinsSection function
async function refreshSkinsSection() {
    try {
        const response = await fetch('/get_inventory');
        const data = await response.json();
        
        if (data.error) {
            console.error('Error:', data.error);
            return;
        }
        
        const inventoryItems = document.getElementById('inventory-items');
        if (!inventoryItems) {
            console.error('Could not find inventory-items element');
            return;
        }
        
        // Store the expanded state of all stacks before refresh
        const expandedStacks = new Set();
        document.querySelectorAll('.skin-stack').forEach(stack => {
            const stackedItems = stack.querySelector('.stacked-items');
            if (stackedItems && !stackedItems.classList.contains('hidden')) {
                expandedStacks.add(stack.dataset.stackKey);
            }
        });
        
        // Clear current inventory
        inventoryItems.innerHTML = '';
        
        // Get only non-case items and maintain their original order
        const skinItems = data.inventory.filter(item => !item.is_case);
        
        // Group items by stack key
        const stacks = {};
        skinItems.forEach(item => {
            const stackKey = `${item.weapon}|${item.name}|${item.wear}|${item.stattrak}`;
            if (!stacks[stackKey]) {
                stacks[stackKey] = [];
            }
            stacks[stackKey].push(item);
        });
        
        // Create and append all items at once
        const fragment = document.createDocumentFragment();
        
        Object.entries(stacks).forEach(([stackKey, items]) => {
            if (items.length > 1) {
                // Create stacked item
                const stackDiv = createStackedItem(stackKey, items);
                // Restore expanded state if it was expanded before
                if (expandedStacks.has(stackKey)) {
                    const stackedItems = stackDiv.querySelector('.stacked-items');
                    if (stackedItems) {
                        stackedItems.classList.remove('hidden');
                        const expandText = stackDiv.querySelector('.stack-expand');
                        if (expandText) {
                            expandText.textContent = 'Click to collapse';
                        }
                    }
                }
                fragment.appendChild(stackDiv);
            } else {
                // Create single item
                fragment.appendChild(createSingleItem(items[0]));
            }
        });
        
        // Add all items to the DOM at once
        inventoryItems.appendChild(fragment);
        
        // Add click handlers to all sell buttons
        document.querySelectorAll('.sell-btn').forEach(button => {
            button.addEventListener('click', sellButtonHandler);
        });
        
        // Update the sell all button
        updateSellAllButton();
        
    } catch (error) {
        console.error('Error refreshing skins section:', error);
    }
}

// Helper function to create a stacked item
function createStackedItem(stackKey, items) {
    const firstItem = items[0];
    const div = document.createElement('div');
    div.className = `skin rarity-${firstItem.rarity} skin-stack`;
    div.dataset.stackKey = stackKey;
    div.dataset.floatValue = firstItem.float_value;
    
    const weaponName = firstItem.weapon.toLowerCase()
        .replace('-', '')
        .replace(' ', '')
        .replace('553', '553')
        .replace('galil ar', 'galil')
        .replace('galilar', 'galil');
    const skinName = firstItem.name.toLowerCase().replace(/ /g, '_');
    
    const casePath = CASE_MAPPING[firstItem.case_type] || 'weapon_case_1';
    
    // Create the collapsed view
    div.innerHTML = `
        <div class="stack-collapsed">
            <div class="skin-image">
                ${!firstItem.weapon.startsWith('★') ? `
                    <div class="skin-image-wrapper">
                        <img src="/static/media/skins/${casePath}/${weaponName}_${skinName}.png" 
                             alt="${firstItem.weapon} | ${firstItem.name}">
                        <span class="skin-count">x${items.length}</span>
                    </div>
                ` : ''}
            </div>
            <div class="item-name ${firstItem.stattrak ? 'stattrak' : ''}">
                ${firstItem.stattrak ? 'StatTrak™ ' : ''}${firstItem.weapon}
            </div>
            <div class="item-skin">
                ${firstItem.name} (${firstItem.wear})
            </div>
            <div class="stack-expand">Click to expand</div>
        </div>
        <div class="stacked-items hidden">
            ${items.map((item, index) => `
                <div class="skin rarity-${item.rarity}" data-index="${index}" data-float-value="${item.float_value}" data-stack-key="${stackKey}">
                    <div class="skin-image">
                        ${!item.weapon.startsWith('★') ? `
                            <div class="skin-image-wrapper">
                                <img src="/static/media/skins/${casePath}/${weaponName}_${skinName}.png" 
                                     alt="${item.weapon} | ${item.name}">
                            </div>
                        ` : ''}
                    </div>
                    <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
                        ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
                    </div>
                    <div class="item-skin">
                        ${item.name} (${item.wear})
                    </div>
                    <div class="item-float">Float: ${item.float_value.toFixed(8)}</div>
                    <div class="item-price">$${item.price.toFixed(2)}</div>
                    <button class="btn sell-btn" data-sell-index="${index}">Sell</button>
                </div>
            `).join('')}
        </div>
    `;
    
    return div;
}

// Helper function to create a single item
function createSingleItem(item) {
    const div = document.createElement('div');
    div.className = `skin rarity-${item.rarity}`;
    div.dataset.index = "0";
    div.dataset.floatValue = item.float_value;
    
    const weaponName = item.weapon.toLowerCase()
        .replace('-', '')
        .replace(' ', '')
        .replace('553', '553')
        .replace('galil ar', 'galil')
        .replace('galilar', 'galil')  // Add this line
        .replace(/\s+/g, '');  // Remove any remaining spaces
    const skinName = item.name.toLowerCase().replace(/ /g, '_');
    
    const casePath = CASE_MAPPING[item.case_type] || 'weapon_case_1';
    
    div.innerHTML = `
        <div class="skin-image">
            ${!item.weapon.startsWith('★') ? `
                <div class="skin-image-wrapper">
                    <img src="/static/media/skins/${casePath}/${weaponName}_${skinName}.png" 
                         alt="${item.weapon} | ${item.name}">
                </div>
            ` : ''}
        </div>
        <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
            ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
        </div>
        <div class="item-skin">
            ${item.name} (${item.wear})
        </div>
        <div class="item-float">Float: ${item.float_value.toFixed(8)}</div>
        <div class="item-price">$${item.price.toFixed(2)}</div>
        <button class="btn sell-btn" data-sell-index="0">Sell</button>
    `;
    
    return div;
}

// Update the DOMContentLoaded event handler
document.addEventListener('DOMContentLoaded', () => {
    // Check if there's a new item to add
    const newItemJson = sessionStorage.getItem('newItem');
    if (newItemJson) {
        const item = JSON.parse(newItemJson);
        const inventoryItems = document.getElementById('inventory-items');
        const newIndex = inventoryItems.children.length;
        
        const skinDiv = document.createElement('div');
        skinDiv.className = `skin rarity-${item.rarity}`;
        skinDiv.dataset.index = newIndex;
        skinDiv.dataset.floatValue = item.float_value.toString();
        
        // Create weapon image
        const weaponName = item.weapon.toLowerCase()
            .replace('-', '')
            .replace(' ', '')
            .replace('553', '553');
        const skinName = item.name.toLowerCase().replace(' ', '_');
        
        skinDiv.innerHTML = `
            <div class="skin-image">
                ${!item.weapon.startsWith('★') ? `
                    <div class="skin-image-wrapper">
                        <img src="/static/media/skins/weapon_case_1/${weaponName}_${skinName}.png" 
                             alt="${item.weapon} | ${item.name}">
                        ${item.count && item.count > 1 ? `
                            <span class="skin-count">x${item.count}</span>
                        ` : ''}
                    </div>
                ` : ''}
            </div>
            <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
                ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
            </div>
            <div class="item-skin">
                ${item.name} (${item.wear})
            </div>
            <div class="item-float">Float: ${item.float_value.toFixed(8)}</div>
            <div class="item-price">$${item.price.toFixed(2)}</div>
            <button class="btn sell-btn" data-sell-index="${newIndex}">Sell</button>
        `;
        
        // Add sell button handler
        const sellBtn = skinDiv.querySelector('.sell-btn');
        if (sellBtn) {
            sellBtn.addEventListener('click', async function() {
                const itemElement = this.closest('.skin');
                if (!itemElement) return;
                const index = parseInt(itemElement.dataset.index);
                try {
                    const response = await fetch(`/sell/${index}`, {
                        method: 'POST'
                    });
                    const data = await response.json();
                    
                    if (data.error) {
                        alert(data.error);
                        return;
                    }
                    
                    // Remove the sold item
                    itemElement.style.animation = 'fadeOut 0.3s';
                    setTimeout(() => {
                        itemElement.remove();
                        
                        // Update remaining items' indices
                        document.querySelectorAll('.skin').forEach((skin, newIndex) => {
                            skin.dataset.index = newIndex;
                        });
                    }, 300);
                    
                } catch (error) {
                    console.error('Error:', error);
                    alert('Failed to sell item');
                }
            });
        }
        
        inventoryItems.appendChild(skinDiv);
        
        // Clear the stored item
        sessionStorage.removeItem('newItem');
    }
    
    // Add click handlers to all existing sell buttons
    document.querySelectorAll('.sell-btn').forEach(button => {
        button.addEventListener('click', async function() {
            const itemElement = this.closest('.skin');
            if (!itemElement) {
                console.error('Could not find parent skin element');
                return;
            }
            
            const index = parseInt(itemElement.dataset.index);
            if (isNaN(index)) {
                console.error('Invalid index:', itemElement.dataset.index);
                return;
            }
            
            try {
                const response = await fetch(`/sell/${index}`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.error) {
                    alert(data.error);
                    return;
                }
                
                // Remove the sold item from display with animation
                itemElement.style.animation = 'fadeOut 0.3s';
                setTimeout(() => {
                    itemElement.remove();
                    
                    // Update remaining items' indices
                    document.querySelectorAll('.skin').forEach((skin, newIndex) => {
                        skin.dataset.index = newIndex;
                    });
                }, 300);
                
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to sell item');
            }
        });
    });
});

// Update the updateInventoryDisplay function
async function updateInventoryDisplay() {
    try {
        const response = await fetch('/get_inventory');
        const data = await response.json();
        
        if (data.error) {
            console.error('Error:', data.error);
            return;
        }
        
        const inventoryItems = document.getElementById('inventory-items');
        if (!inventoryItems) {
            console.error('Could not find inventory-items element');
            return;
        }
        
        // Clear current inventory
        inventoryItems.innerHTML = '';
            
        // Add each item
        let skinIndex = 0;
        for (const item of data.inventory) {
            if (!item.is_case) {
                // Create the skin element
                const skinDiv = document.createElement('div');
                skinDiv.className = `skin rarity-${item.rarity}`;
                skinDiv.dataset.index = skinIndex;  // Set the correct index
                skinDiv.dataset.floatValue = item.float_value.toString();
                
                const weaponName = item.weapon.toLowerCase()
                    .replace('-', '')
                    .replace(' ', '')
                    .replace('553', '553')
                    .replace('galil ar', 'galil')
                    .replace('galilar', 'galil');
                const skinName = item.name.toLowerCase().replace(/ /g, '_');
                const casePath = CASE_MAPPING[item.case_type] || 'weapon_case_1';
                
                skinDiv.innerHTML = `
                    <div class="skin-image">
                        ${!item.weapon.startsWith('★') ? `
                            <div class="skin-image-wrapper">
                                <img src="/static/media/skins/${casePath}/${weaponName}_${skinName}.png" 
                                     alt="${item.weapon} | ${item.name}">
                                ${item.count && item.count > 1 ? `
                                    <span class="skin-count">x${item.count}</span>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                    <div class="item-name ${item.stattrak ? 'stattrak' : ''}">
                        ${item.stattrak ? 'StatTrak™ ' : ''}${item.weapon}
                    </div>
                    <div class="item-skin">
                        ${item.name} (${item.wear})
                    </div>
                    <div class="item-float">Float: ${item.float_value.toFixed(8)}</div>
                    <div class="item-price">$${item.price.toFixed(2)}</div>
                    <button class="btn sell-btn" data-sell-index="${skinIndex}">Sell</button>
                `;
                
                // Add sell button handler
                const sellBtn = skinDiv.querySelector('.sell-btn');
                if (sellBtn) {
                    sellBtn.addEventListener('click', async function() {
                        await sellItem(skinIndex);
                    });
                }
                
                inventoryItems.appendChild(skinDiv);
                skinIndex++;
            }
        }
        
    } catch (error) {
        console.error('Error updating inventory:', error);
    }
}

// Add this function after the existing scripts
function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    document.body.appendChild(confettiContainer);
    
    const colors = ['#ffd700', '#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff'];
    
    // Create 100 confetti pieces
    for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animation = `confettiFall ${1 + Math.random() * 2}s linear forwards`;
        confetti.style.animationDelay = Math.random() * 3 + 's';
        confettiContainer.appendChild(confetti);
    }
    
    // Remove the container after animations complete
    setTimeout(() => {
        confettiContainer.remove();
    }, 5000);
}

function showLevelUpBanner(newRank) {
    const banner = document.createElement('div');
    banner.className = 'level-up-banner';
    banner.innerHTML = `<h2>LEVEL UP: ${newRank}</h2>`;
    document.body.appendChild(banner);
    
    // Remove the banner after animation
    setTimeout(() => {
        banner.remove();
    }, 3000);
}

// Update sell all button click handler
document.getElementById('sell-all-btn').addEventListener('click', function() {
    const totalValue = parseFloat(this.dataset.totalValue);
    if (totalValue <= 0) return;
    
    const modal = document.getElementById('sell-all-modal');
    const modalPrice = document.getElementById('modal-price');
    modalPrice.textContent = `$${totalValue.toFixed(2)}`;
    modal.classList.remove('hidden');
});

// Add sell all functionality
document.getElementById('sell-all-btn').addEventListener('click', function() {
    const totalValue = parseFloat(this.dataset.totalValue);
    if (totalValue <= 0) return;
    
    const modal = document.getElementById('sell-all-modal');
    const modalPrice = document.getElementById('modal-price');
    modalPrice.textContent = `$${totalValue.toFixed(2)}`;
    modal.classList.remove('hidden');
});

document.getElementById('cancel-sell-all').addEventListener('click', function() {
    document.getElementById('sell-all-modal').classList.add('hidden');
});

document.getElementById('confirm-sell-all').addEventListener('click', async function() {
    try {
        console.log('=== Starting Sell All ===');
        
        // Check if case opening animation is in progress
        const overlay = document.getElementById('case-opening-overlay');
        if (overlay && !overlay.classList.contains('hidden')) {
            alert('Please wait for case opening animation to complete');
            return;
        }
        
        console.log('Sending sell all request');
        const response = await fetch('/sell/all', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        const data = await response.json();
        console.log('Sell all response:', data);
        
        if (data.error) {
            console.error('Server error:', data.error);
            alert(data.error);
            return;
        }

        // Update balance display immediately
        const balanceElement = document.querySelector('.balance');
        if (balanceElement) {
            balanceElement.textContent = `Balance: $${data.balance.toFixed(2)}`;
        }
        
        // Handle achievement completion
        if (data.achievement) {
            showAchievementPopup(data.achievement);
        }
        
        // Handle level up
        if (data.levelUp) {
            createConfetti();
            showLevelUpBanner(data.rankName);
        }
        
        // Update rank progress if provided
        if (data.exp !== undefined && data.rank !== undefined) {
            updateRankProgress(data.exp, data.rank, data.rankName, data.nextRankExp);
        }
        
        // Remove all skins with animation
        const skins = document.querySelectorAll('.skin');
        skins.forEach(skin => {
            skin.style.animation = 'fadeOut 0.3s';
        });
        
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Clear inventory display
        const inventoryItems = document.getElementById('inventory-items');
        inventoryItems.innerHTML = '';
        
        // Reset sell all button
        const sellAllBtn = document.getElementById('sell-all-btn');
        sellAllBtn.textContent = 'Sell All: $0.00';
        sellAllBtn.dataset.totalValue = '0';
        
        // Update case display with remaining cases
        if (data.remaining_cases) {
            const casesSection = document.getElementById('cases-section');
            if (casesSection) {
                const casesGrid = casesSection.querySelector('.items-grid');
                if (casesGrid) {
                    casesGrid.innerHTML = '';
                    data.remaining_cases.forEach(item => {
                        if (item.is_case) {
                            const caseDiv = document.createElement('div');
                            caseDiv.className = 'case-item';
                            caseDiv.innerHTML = `
                                <img src="/static/media/cases/${item.image}" alt="${item.name}">
                                <div class="item-details">
                                    <h3>${item.name}</h3>
                                    <p>Quantity: ${item.quantity}</p>
                                    <div class="case-buttons">
                                        <button class="btn-small" onclick="openCase('${item.type}', 1)">Open 1x</button>
                                        ${item.quantity >= 2 ? `<button class="btn-small" onclick="openCase('${item.type}', 2)">Open 2x</button>` : ''}
                                        ${item.quantity >= 3 ? `<button class="btn-small" onclick="openCase('${item.type}', 3)">Open 3x</button>` : ''}
                                        ${item.quantity >= 4 ? `<button class="btn-small" onclick="openCase('${item.type}', 4)">Open 4x</button>` : ''}
                                        ${item.quantity >= 5 ? `<button class="btn-small" onclick="openCase('${item.type}', 5)">Open 5x</button>` : ''}
                                    </div>
                                </div>
                            `;
                            casesGrid.appendChild(caseDiv);
                        }
                    });
                }
            }
        }

    } catch (error) {
        console.error('Error:', error);
        alert('Failed to sell all items');
    } finally {
        document.getElementById('sell-all-modal').classList.add('hidden');
    }
});

// Add this function to ensure case opening overlay is properly reset
function resetCaseOpeningOverlay() {
    console.log('Starting resetCaseOpeningOverlay');
    const overlay = document.getElementById('case-opening-overlay');
    console.log('Found overlay:', overlay);
    
    if (overlay) {
        overlay.classList.add('hidden');
        const spinnerContainers = overlay.querySelectorAll('.spinner-container');
        console.log('Found spinner containers:', spinnerContainers.length);
        
        spinnerContainers.forEach((container, index) => {
            console.log(`Resetting container ${index}`);
            container.classList.add('hidden');
            const spinner = container.querySelector('.spinner');
            if (spinner) {
                spinner.innerHTML = '';
                spinner.style.transform = 'translateX(0)';
                console.log(`Reset spinner ${index}`);
            }
        });
    } else {
        console.warn('No case opening overlay found during reset');
    }
}

// Update category switching to show/hide sell all button
document.querySelectorAll('.category-btn').forEach(button => {
    button.addEventListener('click', () => {
        const sellAllBtn = document.getElementById('sell-all-btn');
        if (button.dataset.category === 'skins') {
            sellAllBtn.style.display = 'block';
        } else {
            sellAllBtn.style.display = 'none';
        }
    });
});

// Update the sorting functions
function sortByRarity(a, b, ascending = false) {
    const rarityOrder = {
        'CONTRABAND': 6,  // Add CONTRABAND as highest rarity
        'GOLD': 5,
        'RED': 4,
        'PINK': 3,
        'PURPLE': 2,
        'BLUE': 1
    };
    const comparison = rarityOrder[b.dataset.rarity] - rarityOrder[a.dataset.rarity];
    return ascending ? -comparison : comparison;
}

function sortByPrice(a, b, ascending = false) {
    const priceA = parseFloat(a.querySelector('.item-price').textContent.replace('$', ''));
    const priceB = parseFloat(b.querySelector('.item-price').textContent.replace('$', ''));
    return ascending ? priceA - priceB : priceB - priceA;
}

// Update the sort button click handlers
document.addEventListener('DOMContentLoaded', () => {
    // ... existing DOMContentLoaded code ...

    const sortButtons = document.querySelectorAll('.sort-btn');
    sortButtons.forEach(button => {
        button.addEventListener('click', () => {
            // Only sort if we're in the skins section
            if (!document.getElementById('skins-section').classList.contains('hidden')) {
                // Toggle active state only on clicked button
                if (button.classList.contains('active')) {
                    // If already active, toggle direction
                    button.classList.toggle('asc');
                } else {
                    // Remove active and asc classes from all sort buttons
                    sortButtons.forEach(btn => {
                        btn.classList.remove('active', 'asc');
                    });
                    // Add active class to clicked button
                    button.classList.add('active');
                }

                const sortType = button.dataset.sort;
                const ascending = button.classList.contains('asc');
                const inventoryItems = document.getElementById('inventory-items');
                const items = Array.from(inventoryItems.children);

                // Sort items with direction
                items.sort((a, b) => 
                    sortType === 'rarity' ? 
                        sortByRarity(a, b, ascending) : 
                        sortByPrice(a, b, ascending)
                );

                // Clear and re-append items in new order
                inventoryItems.innerHTML = '';
                items.forEach(item => inventoryItems.appendChild(item));

                // Update sell indices after sorting
                items.forEach((item, index) => {
                    item.dataset.index = index;
                    const sellBtn = item.querySelector('.sell-btn');
                    if (sellBtn) {
                        sellBtn.dataset.sellIndex = index;
                    }
                });
            }
        });
    });
});

// Update sell all button when inventory changes
document.addEventListener('DOMContentLoaded', updateSellAllButton);

// Update the refreshSkinsSection function to call updateSellAllButton
const originalRefreshSkinsSection = refreshSkinsSection;
refreshSkinsSection = async function() {
    await originalRefreshSkinsSection();
    updateSellAllButton();
};

// Add this after your existing DOMContentLoaded event listener
document.addEventListener('click', function(e) {
    const stack = e.target.closest('.skin-stack');
    if (stack && !e.target.closest('.sell-btn') && !e.target.closest('.stack-expand')) {
        const stackedItems = stack.querySelector('.stacked-items');
        const expandText = stack.querySelector('.stack-expand');
        const inventoryGrid = document.getElementById('inventory-items');
        
        if (stackedItems) {
            if (stackedItems.classList.contains('hidden')) {
                // Expanding - move items to main grid
                const items = Array.from(stackedItems.children);
                stack.style.display = 'none'; // Hide the stack
                
                // Calculate new starting index based on existing items
                const startIndex = inventoryGrid.children.length;
                
                items.forEach((item, i) => {
                    // Update the item's index and sell button before moving it
                    item.dataset.index = startIndex + i;
                    const sellBtn = item.querySelector('.sell-btn');
                    if (sellBtn) {
                        sellBtn.dataset.sellIndex = startIndex + i;
                    }
                    inventoryGrid.appendChild(item);
                });
            } else {
                // Collapsing - move items back to stack
                const stackKey = stack.dataset.stackKey;
                const items = Array.from(document.querySelectorAll(`.skin[data-stack-key="${stackKey}"]`));
                items.forEach((item, i) => {
                    // Reset indices when moving back to stack
                    item.dataset.index = i;
                    const sellBtn = item.querySelector('.sell-btn');
                    if (sellBtn) {
                        sellBtn.dataset.sellIndex = i;
                    }
                    stackedItems.appendChild(item);
                });
                stack.style.display = ''; // Show the stack
                stackedItems.classList.add('hidden');
            }
            expandText.textContent = stackedItems.classList.contains('hidden') ? 
                'Click to expand' : 'Click to collapse';
                
            // Update all indices after expanding/collapsing
            updateRemainingIndices();
        }
    }
});

// Update the sell all functionality
function updateSellAllButton() {
    const sellAllBtn = document.getElementById('sell-all-btn');
    let totalValue = 0;
    
    // Get all individual skin prices
    document.querySelectorAll('.skin:not(.skin-stack) .item-price').forEach(priceElement => {
        const price = parseFloat(priceElement.textContent.replace('$', ''));
        if (!isNaN(price)) {
            totalValue += price;
        }
    });
    
    // Get all stacked item prices
    document.querySelectorAll('.skin-stack .skin-item').forEach(item => {
        const priceElement = item.querySelector('.item-price');
        if (priceElement) {
            const price = parseFloat(priceElement.textContent.replace('$', ''));
            if (!isNaN(price)) {
                totalValue += price;
            }
        }
    });
    
    // Only show amount if there are items to sell
    if (totalValue > 0) {
        sellAllBtn.textContent = `Sell All: $${totalValue.toFixed(2)}`;
        sellAllBtn.dataset.totalValue = totalValue;
    } else {
        sellAllBtn.textContent = 'Sell All: $0.00';
        sellAllBtn.dataset.totalValue = '0';
    }
}
</script>
{% endblock %} 